# 03_01 Algorithm_Intro

## 1. 알고리즘 ?

### 1.1 알고리즘과 프로그램

- **'알고리즘'** : 계산이나 작업을 하기 위한 순서, **특정 문제를 컴퓨터로 해결**하기 위한 순서
- **'프로그램'** : 컴퓨터상에서 실행할 수 있도록 **컴퓨터가 이해할 수 있는 언어로 작성**하는 것

### 1.2 알고리즘 선택법

- 간단한 알고리즘은 사람이 이해하기 쉽고 프로그램으로 작성하기 쉽다.

- 실행 중에 기억 영역이 적어도 되는 알고리즘은 메모리가 작은 컴퓨터에서도 동작한다는 이점 존재

- **주어진 입력 값으로 답을 내기까지 걸리는 시간이 중요**

### 1.3 좋은 알고리즘의 특징

- **정밀성** : 변하지 않는 명확한 작업 단계를 가져야 한다.
- **유일성** : 각 단계마다 명확한 다음 단계를 가져야 한다.
- **타당성** : 구현할 수 있고 실용적이어야 한다.
- **입    력** : 정의된 입력을 받아들일 수 있어야 한다.
- **출    력** : 답으로 출력을 내보낼 수 있어야 한다.
- **유한성** : 특정 수의 작업 이후에 정지해야 한다.
- **일반성** : 정의된 입력들에 일반적으로 적용할 수 있어야 한다.

## 2. 계산 시간을 측정하는 방법

### 2.1 입력크기와 계산 시간 관계

- 알고리즘의 실행 시간은 같은 알고리즘이라도 입력 값에 따라 크게 달라진다.
- 하드웨어, 운영체제, 프로그래밍 언어 등 특징에 따라서 최적화된 여러가지 알고리즘이 존재
- **알고리즘 간 실행 시간 차이**뿐 아니라, 같은 알고리즘에서도 **입력의 크기에 따라 알고리즘 계산 시간을 고려**

### 2.2 계산 시간 구하기

- 계산 시간에는 **'스탭 수'**를 활용한다.
  - 1스탭은 계산의 기본 단위
- **'계산을 종료하기까지 기본 단위를 몇 회 실행했는가'**로 계산 시간을 측정

### 2.3 계산 시간 표현하기

- **점근적 분석법**

  - 각 알고리즘이 **주어진 데이터로 수행시간 혹은 사용공간**이 얼마나 되는지를 **객관적 비교 기준 제시**

- O-Notation

  - O는 '중요한 항목 이외는 무시한다'라는 의미를 가지는 기호

    - **_O_(1)** : _n_에 관계없이 일정 시간 이하에 수행되는 알고리즘	예) 파일의 첫번째 바이트가 null인지 검사
    - **_O_(log _n_)** : log<sub>2</sub>_n_에 비례하는 시간 이하에 수행되는 알고리즘 예) 이진 탐색
    - **_O_(_n_)** : _n_에 비례하는 시간 이하에 수행되는 알고리즘   예) 기수 정렬
    - **_O_(_n_ log _n_)** : n에 대략 비례할 수 있는 시간 이하에 수행되는 알고리즘 예) 정렬 알고리즘
    - **_O_(_n_<sup>2</sup>)** : _n_<sup>2</sup>에 비례하는 시간 이하에 수행되는 알고리즘 예) 최장 공통 부분 수열
    - **_O_(_n_<sup>3</sup>)** : _n_<sup>3</sup>에 비례하는 시간 이하에 수행되는 알고리즘 예) 행렬 곱셈
    - **_O_(_a_<sup>n</sup>)** : _2_<sup>n</sup>과 같은 꼴의 수행 시간 이하에 수행되는 알고리즘 예) 충족 가능성 문제
    - **_O_(_n_!)** : _n_!과 같은 꼴의 수행 시간 이하에 수행되는 알고리즘 예) 배열의 모든순열을 검사
  
  - **_O_(1)** < **_O_(log _n_)** < **_O_(_n_)** < **_O_(_n_ log _n_)** < **_O_(_n_<sup>2</sup>)** < **_O_(2<sup>n</sup>)** < **_O_(_n_!)**

​    