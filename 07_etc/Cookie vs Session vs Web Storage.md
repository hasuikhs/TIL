# Cookie vs Session vs Web Storage

## 1. Cookie
- HTTP 프로토콜에는 비연결성과 무상태성이라는 특성때문에 사용자의 요청에 대한 응답이 끝나면 연결 상태를 해제하여, 상태 정보를 저장하지 않기에 서버의 자원을 크게 절약 가능하였음
- 그러나 **사용자를 식별할 수 없어서, 매번 새로운 사용자로 인식하는 단점이 존재**
- 이 문제를 해결하기 위해서 서버는 클라이언트의 인증 정보를 확인하고 응답 Header에 `Set-Cookie` 속성에 추가하여 반환
- 클라이언트는 이후 서버에 요청할 때 이 **쿠키 값을 자동으로 Requset Header에 추가하여 서버에 전달**

### 1.1 Cookie ?

- 웹 서버가 브라우저에게 지시하여 **사용자의 로컬 컴퓨터에 파일 또는 메모리에 저장하는 작은 기록 정보 파일**
- 해당 **웹사이트에서 발행한 쿠키가 없을 때 생성**
- 파일에 담긴 정보는 인터넷 사용자가 **같은 웹사이트를 방문할 때마다 읽히고 수시로 새로운 정보로 바뀜**

#### 쿠키의 사용 예

- **인증 유지**: 로그인 세션을 유지하여 사용자가 매번 로그인 필요 없게 함
- **사용자 설정 저장**: 웹사이트 설정, 테마, 언어 등 사용자의 설정을 저장하여 다음 방문 시 동일한 환경 제공 가능
- **쇼핑 카트**: 전자상거래 사이트에서 사용자가 장바구니에 담음 상품을 기억
- **트래킹 및 분석**: 사용자의 웹사이트 사용 패턴을 분석하여 맞추형 광고를 제공하거나 웹사이트 성능을 개선하는 데 사용

### 1.2 쿠키의 구성요소

- **Name** : 쿠키의 이름
- **Value** : 쿠키에 저장된 값
- **Expires** : 쿠키가 언제 삭제되는지 결정
- **Domain** : 쿠키가 사용되는 도메인을 지정
  - 이 값이 현재 탐색 중인 도메인과 일치하지 않을 경우, '타사 쿠키'로 간주되며 브라우저에서 거부
  - 이렇게 해서 한 도메인에서 다른 도메인에 대한 쿠키를 사용하지 못하게 설정
- **Path** : 쿠키를 반환할 경로를 결정
- **SameSite**: 쿠키의 SameSite 속성은 쿠키가 사이트 간 요청과 함께 보내지는 방식을 제어하여 CSRF(Cross-Site Request Forgery) 공격을 방지하는데 도움
  - **Strict**: 쿠키가 동일한 사이트 내에서만 전송
  - **Lax**: 기본값으로, 일부 사이트 간 요청과 함께 전송
  - **None**: 쿠키가 모든 사이트 간 요청과 함께 전송, **보안을 위해 Secure 속성 필요**
- **Secure** : 보안 연결 설정V
- **HttpOnly** : Http 외에 다른 통신 사용 가능 설정

### 1.3 쿠키의 종류

- 쿠키는 크게 1사 쿠키와 3사 쿠키 두 가지 유형으로 구분 가능
  - **1사 쿠키** : 사용자가 방문한 웹사이트에 의해 생성된 쿠키로서 <br>				  이 1사 쿠키를 발급한 웹사이트만 이들 쿠키를 읽을 수 있음
  - **3사 쿠키** : 사용자가 **방문한 웹사이트가 아닌 제 3의 웹사이트**(서비스, 매체, 솔루션 등)에 의해 생성된 쿠키
    - 구글 크롬은 2022년 1월 전에 수집되는 데이터에 대한 투명성, 사용자의 선택권과 통제권을 강화를 위해 중단할 예정
    - [대안](https://brunch.co.kr/@digitalnative/16)

|       쿠키 이름        |                            특 징                             |
| :--------------------: | :----------------------------------------------------------: |
|  **Temporary Cookie**  | 보통 만료시간(Expire date)가 정해지지 않고 메모리에만 저장되며<br>웹 세션을 종료하거나 브라우저 종료시 쿠키를 삭제 |
| **Persistent Cookie**  | 장시간 유지되는 쿠키<br>파일로 저장되어 브라우저 종료와 관계없이 사용 |
|   **Secure Cookie**    |       HTTPS에서만 사용<br>쿠키 정보가 암호화되어 전송        |
| **Third-Party Cookie** | 방문한 도메인과 다른 도메인의 쿠키 보통 광고 배너 등을 관리할 때<br>유입 경로를 추적하기 위해 사용 |

### 1.4 쿠키의 단점

- 쿠키에 대한 정보를 매 헤더(Http Header)에 추가하여 보내기 때문에 **상당한 트래픽**을 발생
- 결제 정보 등을 쿠키에 저장하였을때 쿠키가 유출되면 **보안에 대한 문제점**도 발생 가능

## 2. Session

- 쿠키의 **트래픽 문제와 쿠키를 변경하는 보안적 이슈를 해결하기 위해 등장**
- 결제 정보 등을 쿠키에 저장하였을때 쿠키가 유출되면 **보안에 대한 문제점**도 발생 가능
- **브라우저의 저장 공간 제한**: 각 도메인당 저장할 수 있는 쿠키의 개수와 크기에 제한(일반적으로 각 쿠키는 최대 4KB, 도메인당 약 20개의 쿠키)
- **프라이버시 문제**: 쿠키는 사용자의 브라우징 행동을 추적하는 데 사용될 수 있습니다. Third-Party Cookie는 특히 사용자의 활동을 여러 사이트에 걸쳐 추적

### 2.1 Session ?

- HTTP Session id를 식별자로 구별하여 데이터를 접속한 **서버 DB에 정보를 저장**
- 클라이언트는 HTTP Session id를 쿠키로 메모리 저장된 형태로 가지고 있음
- 메모리에 저장하기 때문에 **브라우저가 종료되면 사라짐**

### 2.1 세션(HTTP Session) 절차

1. 클라이언트가 서버에 Resource를 요청
2. 서버에서는 HTTP Request를 통해 쿠키에서 Session id를 확인 후에 없으면 Set-Cookie를 통해 새로 발행한 Session-id를 보냄
3. 클라이언트는 HTTP Request 헤더에 Session id를 포함하여 원하는 Resource를 요청
4. 서버는 Session id를 통해 해당 Session을 찾아 클라이언트 상태 정보를 유지하며 적절한 응답을 함

### 2.2 Server-Side 관점의 세션

#### 2.2.1 장점

- 서버에 저장하기 때문에 매우 **관리하기 편하고 효율적**

#### 2.2.2 단점

- Load-Balancing/시스템 효율성에서 Handling하기 어려움
- 세션 저장 장치가 부족한 시스템에는 적합하지 않음

#### 2.2.3 해결 방법

- **Load-Balancing 문제**
  - 세션 정보를 하나의 저장 장치에 공유하는 것
  - 각각의 클라이언트를 다른 서버에 Binding하는 방법
  - 비록 Load-Balancing 관점과 시스템 효율성이 떨어지더라도 어느 정도 감수
  - **Sticky Sessions**: 클라이언트가 최초로 연결된 서버에 지속적으로 연결되도록하는 방법, 이는 Load Balancer가 클라이언트 요청을 항상 동일한 서버로 전달하도록 설정
    ```bash
    # nginx
    upstream backend {
      ip_hash;
      server backend1.example.com;
      server backend2.example.com;
    }
    ```
- **저장 장치**
  - 엄청난 용량의 저장 장치를 사용하는 대신 Memory 기반의 저장장치를 사용
  - 대신 Client의 최대 인원을 제한하는 단점이 있지만, 세션 스토리지의 용량 문제를 해결하는데 도움이 됨

### 2.3 Client-Side 관점의 세션

- 서버에 많은 양의 정보를 저장하지 않고 상태를 유지하기 위해 암호화가 적용된 쿠키를 사용
- 클라이언트에 저장된 쿠키가 데이터가 소프트웨어나 다른 사용자에 의해 손상될 경우도 있음
- 클라이언트 세션은 **기밀성과 무결성이 보장되어야 함**

### 2.4 보장되어야 할 것

- **Confidentiality(비밀성)** : 서버 이외에는 어느 누구도 세션 데이터를 해석 불가능해야 함, 세션 데이터는 HTTPS를 통해 암호화된 채널로 전송
- **Data Integrity(데이터 무결성)** : 서버와 별개로 세션 데이터를 조작해서는 안됨(실수 or 악의적)
- **Authenticity(진정성)** : 서버를 제외하고는 올바른 세션을 시작할 수 없음

### 2.5 정책

- 서버는 세션 데이터를 클라이언트에게 보내기 전에 **암호화**해야 함
- 웹 브라우저들을 쿠키의 크기와 개수의 제한을 두고있음
- 더 많은 세션 데이터를 허용하고 효율적으로 관리하기 위해서는 
  - **쿠키를 만들기 전에 데이터를 압축하는 과정**이 필요
  - 클라이언트에게 **쿠키를 받기 전 압축 해제하는 과정**이 필요

## 3. Web Storage

### 3.1 Web Storage ?

- HTML5 이상에서 웹의 데이터를 클라이언트에 저장 가능
- Web Storaged의 개념은 key-value 쌍으로 에이터를 저장하고 key를 기반으로 데이터를 조회
- 영구 저장소(Local Storage)와 임시 저장소(Session Storage)를 따로 두어 데이터의 지속성을 구분 가능
- 기존 웹 환경의 쿠키와 매우 유사
- 최소 5MB 이상의 많은 공간을 가지며, 절대 서버로 전송되지 않음

### 3.2 쿠키와의 차이점

- **쿠키는 매번 서버로 전송**
  - 웹 사이트에서 쿠키를 서정하면 모든 웹 요청은 쿠키를 포함하여 서버로 전송
  - Web Storage는 저장된 데이터가 클라이언트에 존재할 뿐 서버에 전송되지 않아 네트워크 트래픽 비용 절감
- **단순 문자열을 넘어 객체 정보를 저장 가능**
  - 문자열 기반 데이터 이외에 체계적으로 구조화된 객체 저장 가능
  - 개발 편의성을 제공해주는 주요한 장점
  - 데이터를 저장하거나 불러올 때 `JSON.stringify()`와 `JSON.parse()`를 사용해 객체 형태로 저장 및 조회 가능
- **영구 데이터 저장 가능**
  - 쿠키는 만료 일자를 지정하게 되어 있어 언젠가 제거
  - Local Storage는 데이터를 명시적으로 지우지 않는 한 영구적으로 저장 가능

### 3.3 Local Storage

- 데이터를 명시적으로 지우지 않는 이상 영구적 보관 가능
- 도메인마다 별도로 Local Storage 생성
- Windows 전역 객체의 Local Storage 컬렉션을 통해 저장과 조회, `window.localStorage`
- 서버로 localhost로 실행하는 것이 아닌 일반 html 파일을 개별적으로 실행하였을때도 같은 파일 시스템을 공유한다면 파일명이 달라도 데이터가 공유됨

### 3.4 Session Storage

- 데이터의 지속성과 액세스 범위에 특수한 제한 존재
- Windows 전역 객체의 Session Storage라는 컬렉션을 통해 저장과 조회, `window.sessionStorage`
- 현재 페이지가 브라우징되고 있는 브라우저 컨텍스트 내에서만 데이터가 유지. 즉, 브라우저가 종료되면 삭제
  - 브라우저 탭을 삭제하면 같이 없어지지만, 닫힌 탭 다시 열기(`ctrl` + `shift` + `t`)로 다시 열면 복구되는 것을 확인 가능

### 3.5 추가 사항

- **보안 이슈**
  - Web Storage에 저장된 데이터는 브라우저의 개발자 도구를 통해 쉽게 접근할 수 있어 민감한 정보를 저장하는 데는 적합하지 않음
  - 민감한 정보를 저장할 때는 항상 암호화를 고려해야 함
- **용량 제한**
  - Local Storage와 Session Storage 모두 대부분의 브라우저에서 약 5MB의 저장 용량을 제공하는데, 브라우저마다 다를 수 있음
- **브라우저 지원**
  - 대부분의 현대 브라우저는 Local Storage와 Session Storage를 지원하지만, 구형 브라우저에서는 지원하지 않을 수 있으므로 호환성을 확인해야 함