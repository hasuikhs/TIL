# 시스템 성능 구조

## 1. 성능 기초 개념

### 1.1 알고리즘

#### 1.1.1 알고리즘이란 ?

- 어떠한 문제를 해결하기 위한 일련의 절차나 방법을 공식화한 형태로 표현한 것
- 계산을 실행하기 위한 단게적 절차를 의미

#### 1.1.2 알고리즘을 배우는 방법

- 장점과 단점을 파악
  - 알고리즘에는 장점과 단점이 늘 공존하는데, 인식하지 못해서 발생하는 문제 존재
- 그림을 그려서 생각
  - 성능은 그림을 그려 가면서 이해하는것이 중요
  - 가능한 한 스스로 그림을 그려 가면서 다른 사람에게 설명해볼 것

### 1.2 알고리즘과 성능

#### 1.2.1 성능 영향 정도

> - 100만 개 데이터에서 특정 데이터를 검색하는 경우(하나의 데이터를 보는데 1ms)
>  1. 확률적으로 반 정도를 보면 데이터를 찾을 수 있으므로 50만 x 1ms = 500초 소요
>  2. 이진 탐색 알고리즘의 경우 1회째 50만, 2회째 25만으로 반씩 줄어들어 20회 째에 조사 대상이 한 개가 되어 20ms가 소요

- 자잘한 오버헤드(overhead) 무시 가능
  - 전체적인 관점에서 자잘한 처리는 무시해도 좋을 정도(40ms나 60ms는 무시)
- 중요한 것은 데이터 양이 증가할 때 어떤 형태로 시간이 늘어나는가임
  - 데이터가 적을 때 성능이 좋아도 수천~수만 건일때 성능이 급격히 저하되는 알고리즘이 존재하기 때문

#### 1.2.2 알고리즘 평가 지표

![image-20200513113554338](시스템_성능_구조.assets/image-20200513113554338.png)

- 2n의 2는 큰 영향을 주지 못한다는 것이 앞서 자잘한 오버헤드는 무시 가능함을 보여줌

- **계산량이란?**
- y=n이나 y=2n에서는 'O(n)'이라고 표기하며 '오더 엔'이라 읽음
  - 트리 구조 같은 이진 탐색에서는 'O(logn)'인데 수가 커져도 늘어나는 시간은 적음
  - ![image-20200513115209628](시스템_성능_구조.assets/image-20200513115209628.png)


### 1.3 응답과 처리량

- **응답(Response)** : 요청에 얼마나 빠르게 반응 가능한지
  - 응답 중심 시스템
    - 응답이 빠르면 보통 처리량도 올라가기때문에 만능처럼 보임
    - CPU clock이나 디스크 I/O 속도에 한계가 있으므로 물리적으로 불가능
- **처리량(Throughput)** : 처리 가능한 양이 많은지
  - 처리량 중심 시스템
    - 동시에 대량 처리를 하는 시스템
- 성능을 고려할 때는 응답 중심인지 처리량 중심인지를 항상 인지

### 1.4 성능의 중요 기술

#### 1.4.1 캐시(Cache)

- 캐시는 컴퓨터에서 성능 향상을 목적으로 사용
- 성능 목적이기 때문에 배치 위치보단 빠른 속도가 중요
- 데이터 갱신 방법에 따라 **라이트 백(Write Back)**과 **라이트 스루(Write Through)**로 나뉨
  - **라이트 백**
    - 데이터 갱신 시 정식 데이터는 갱신 X, 캐시 데이터만 갱신 후 정식 데이터를 갱신하는 방법
    - 장점
      - 정식 데이터의 위치는 멀리 떨어져 있어 처리 속도가 느리지만, 라이트백은 정식 데이터 기록을 기다리지 않으므로 속도가 빠름
    - 단점
      - 캐시 데이터가 망가지면 정식 데이터가 오래된 데이터를 보유할 경우에 불일치 문제 발생, 정식 데이터도 항상 최신 상태로 유지하려면 라이트 스루 방식 사용
  - **라이트 스루**
    - 정식 데이터도 반드시 갱신해야 하는 경우
    - 시간이 걸리지만 데이터를 확실하게 갱신 가능한 방법
    - 장점
      - 캐시에 데이터 존재 시 읽기 처리가 빠르고, 쓰기 처리도 보장
    - 단점
      - 정식 데이터에 기록하기까지 시간이 걸리기 때문에 응답 지체 가능

#### 1.4.2 락(Lock)과 성능

> 어느 구조에서 특정 위치에 동시에 데이터를 입력하려 한다면 구조는 망가진다. 이와 같은 사태를 방지하기 위해서는 갱신 중에는 다른 프로그램의 갱신 처리를 기다려야한다.

- 락은 병렬로 처리할 때 필요한 메커니즘
- 특정 처리가 진행되고 있는 상태를 보호하기 위한 구조이자, 다른 처리가 끼어들지 못하도록 하는 것
- 락 대기는 하나의 처리만 실행될 때는 발생하지 않기에 개발 시에는 인지하지 못하는 경우가 다수 존재
- **락 대기를 해결할 방법**
  - 기본적인 해결책은 락이 된 처리를 빨리 끝내는 것
    - DB 테이블에 락을 건 상태에서 SQL을 발행한 경우 해당 SQL을 빠르게 끝내면 됨
  - 락을 분할하는 방법
    - DB 테이블에 락을 거는 것이 아니라, 레코드에 대해 락을 걸어서 SQL 발행 시 병렬 실행 가능
    - 이처럼 락 단위를 작게 해서 대기 시간 감소 가능

---

## 2. 성능 분석의 기본

### 2.1 측정

- 측정이 되지 않으면 성능에 대해 언급이 불가능

- 성능 문제 대처나 성능 튜닝은 바른 측정이 수반되어야 가능

### 2.2 필요한 성능 정보

#### 2.2.1 '샌드위치' 원칙

- 성능 측정의 기본으로 시간적인 전후 관계와 장소적인 전후 관계 모두 고려
- 어느 정도 시간의 성능 문제인지, 어떤 부분에서 느려지는 문제인지 이것을 사전에 파악하고 있다면, 사용해야 할 측정 툴과 대상 범위를 좁히기 가능
- 부하가 걸리는 툴도 존재하기 때문에 범위를 좁게 한다고 좋은 것만은 아님

#### 2.2.2 성능 정보 세 가지

- **요약 형식**
  - 일정 시간 단위로 정보의 합계나 평균을 보여주는 방식
  - 초기 단계 정보 파악용으로는 편리
  - 값이 평균화되기 때문에 기간 내 변동은 파악하기 어려움
- **이벤트 기록 형식**
  - 개별 처리(이벤트)를 순차적으로 기록하는 방식
  - 이벤트 기록 형식의 툴 대부분은 성능 데이터가 방대해지는 단점 존재
  - 부하가 커서 상용 환경에 적용하기는 어려움
  - 어느 정도 문제를 파악한 후 상세한 내용을 조사하기 위한 툴
- **스냅 샷**
  - 순간의 상태를 기록하는 방식
  - 정기적으로 촬영을 하게 되면 성능 문제를 해결하는데 도움
  - 원인 판명 시에 유용

#### 2.2.3 데이터 종류와 분석 비법

- 요약 형식
  - 과거 시점의 대략적인 상태를 조사하기에 유리하지만 원인 조사가 어려움
  - 대략적인 상태(현상)으로부터 원인을 추측해야 함
- 이벤트 기록 형식
  - 성능 파악 시에 '도착과 출발'을 항상 의식
  - 도착과 출발의 경우 같은 장비에서 측정하는 것이 중요(장비 간 시간이 미묘하게 차이 나는 경우 존재)
- 스냅샷 형식
  - 원인을 조사하기에 적합하며 정보를 프로세스, 스레드, 처리 단위로 취득
  - 확인해야할 정보가 많지만, 문제 시간을 파악 가능하다면 해당 시간대 처리만 조사하면 되기에 원인 파악이 용이



