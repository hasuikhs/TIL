# 12. 기본 인증

## 12.1 인증

### 12.1.1 HTTP의 인증 요구/응답 프레임워크

- HTTP는 사용자 인증을 하는 데 사용하는 자체 인증 요구/응답 프레임워크 제공
- 웹 애플리케이션이 HTTP 요청 메시지를 받으면, 서버는 요청을 처리하는 대신에 현재 사용자가 누구인지를 알 수 있게 비밀번호 같이 개인 정보를 요구하는 '인증 요구'로 응답 가능

- 사용자가 다시 요청을 보낼 때는 인증 정보를 첨부해야함
- 인증 정보가 맞지 않으면 다시 인증 요구를 하거나 에러를 낼 수 있음

### 12.1.2 인증 프로토콜과 헤더

- HTTP에는 기본 인증과 다이제스트 인증이라는 두가지 공식적인 인증 프로토콜 존재

- 기본 인증

  | 단계      | 헤더                | 설명                                                         | 메서드/상태      |
  | --------- | ------------------- | ------------------------------------------------------------ | ---------------- |
  | 요청      |                     | 첫 요청은 인증 정보 없음                                     | GET              |
  | 인증 요구 | WWW-Authenticate    | 서버는 사용자에게 인증 정보를 제공하라고 401과 함께 요청 반려<br>서버에는 각각 다른 비밀번호가 있는 영역이 있으므로, 서버는 WWW-Authentication 헤더에 해당 영역을 설명 | 401 Unauthorized |
  | 인증      | Authorization       | 클라이언트는 인증 알고리즘과 사용자 인증 정보를 기술한 Authorization 헤더를 함께 보냄 | GET              |
  | 성공      | Authentication-Info | 인증 정보가 맞으면, 서버는 문서와 함께 응답<br>어떤 인증 알고리즘은 선택적 헤더인 Authentication-Info에 추가 정보를 기술 | 200 OK           |

### 12.1.3 보안 영역

- 웹 서버는 기밀문서를 보안 영역(realm) 그룹으로 나눔
- 보안 영역은 저마다 다른 사용자 권한을 요구

## 12.2 기본 인증

- 기본 인증은 가장 잘 알려진 HTTP 인증 규약

- 거의 모든 주요 클라이언트와 서버에 기본 인증이 구현

### 12.2.1 기본 인증

| 인증요구/응답                | 헤더 문법과 설명                                             |
| ---------------------------- | ------------------------------------------------------------ |
| 인증요구(서버 -> 클라이언트) | 사이트의 보안 영역마다 다른 비밀번호 존재<br>realm은 요청 받은 문서 집합의 이름으로, 사용자는 이를 보고 어떤 비밀번호를 사용하는지 인지<br>`WWW-Authenticate: Basic realm='문서 집합'` |
| 응답(클라이언트 -> 서버)     | 인증정보는 콜론으로 잇고, base-64로 인코딩해서 국제문자를 포함 가능케 하고, 네트워크 트래픽에 노출되지 않게 함<br>`Authorization: Basic base-64로 인코딩한 계정 정보` |

###  12.2.2 Base-64 사용자 이름/비밀번호 인코딩

- HTTP 기본 인증은 계정 정보를 콜론으로 이어서 합치고, base-64 인코딩 메서드를 사용해 인코딩
- base-64 인코딩은 8비트 바이트로 이루어져 있는 시퀀스를 6비트 덩어리의 시퀀스로 변환
- 각 6비트 조각은 대부분 문자와 숫자로 이루어진 특별한 64개 문자 중에서 선택 됨
- base-64 인코딩은 바이너리, 텍스트, 국제 문자 데이터 문자열을 받아서 전송가능하게 알파벳으로 변환하기 위해 발명
- 전송 중에 원본 문자열이 변질될 걱정 없이 원격에서 디코딩 가능
- 어렵지 않게 사용자 이름과 비밀번호를 보내야 할 때 유용

### 12.2.3 프락시 인증

- 어떤 회사는 사용자들이 회사의 서버나 LAN이나 무선 네트워크에 접근하기 전에 프락시 서버를 거치게 하여 사용자 인증 함
- 프락시 서버에서 접근 정책을 중앙 관리 가능하므로, 회사 리소스 전체에 해 통합적인 접근 제어에 용이

## 12.3 기본 인증의 보안 결함

- 기본 인증은 단순하고 편리하지만 안심 불가능
- 기본 인증은 악의적이지 않은 누군가가 의도치 않게 리소스에 접근하는 것을 막는데 사용하거나, SSL 같은 암호 기술과 혼용
- 보안 결함
  1. base-64로 인코딩된 인증 정보가 손쉽게 디코딩 가능
  2. 보안 비밀번호가 디코딩하기 더 복잡한 방식으로 인코딩되어 있더라도, 제 3자는 읽기 힘든 정보를 그대로 캡처 후 원서버에 그대로 보냄으로서 인증에 성공 가능
  3. 보안이 뚫린 애플리케이션이 별로 치명적이지 않더라도, 일반 사용자들은 같은 계정 정보를 사용하는 경우가 많으므로 다른 중요한 사이트에 접근 가능
  4. 메시지의 인증 헤더를 건드리지는 않지만, 그 외 다른 부분을 수정해서 트랜젝션의 본래 의도를 바꿔버리는 프락시나 중개자가 개입하는 경우, 기본 인증은 정상적인 동작을 보장하지 않음
  5. 기본 인증은 가짜 서버의 위장에 취약
- 기본 인증은 일반적인 황경에서 개인화나 접근을 제어하는데 편리
- 다른 사람들이 보더라도 치명적이지 않은 경우에는 여전히 유용