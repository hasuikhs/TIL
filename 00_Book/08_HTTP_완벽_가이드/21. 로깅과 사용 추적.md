# 21. 로깅과 사용 추적

## 21.1 로그란 무엇인가?

- 로깅을 하는 이유
  - 서버나 프락시의 문제 찾기 위함
  - 웹 사이트 접근 통계를 내리기 위함
- HTTP 트랜젝션의 모든 헤더를 로깅 가능하지만, 하루에 수없이 많은 트래픽을 처리하는 서버나 프락시에서 로깅은 감당 불가
- HTTP 메서드와 URL은 어떤 요청이 어떤 일을 하려고 했는지 가리킴
- 버전 정보는 클라이언트와 서버 간에 문제가 생겼을 때 디버깅하는데 도움이 될 클라이언트와 서버 정보 제공
- HTTP 상태 코드는 요청의 처리 상태 정보 제공
- 요청/응답 크기와 타임스탬프는 주로 계측하는데 사용

## 21.2 로그 포맷

- 상용 혹은 오픈 소스 HTTP 애플리케이션은 대부분, 표준 로그 포맷을 한 개 이상 지원
- 애플리케이션 대부분이 로그 포맷을 설정하고 자체 맞춤 포맷을 만들 수 있는 설정 기능 제공

### 21.2.1 일반 로그 포맷

- NCSA가 정의했고, 많은 서버가 이 로그 포맷을 기본으로 사용

- 일반 로그 포맷의 필드

  | 필드          | 설명                                                         |
  | ------------- | ------------------------------------------------------------ |
  | remotehost    | 요청한 컴퓨터의 호스트명 혹은 IP 주소                        |
  | username      | ident 검색을 수행했다면, 인증된 요청자의 사용자 이름 존재    |
  | auth-username | 인증을 수행했다면, 인증된 요청자의 이름 존재                 |
  | timestamp     | 요청 날짜와 시간                                             |
  | request-line  | HTTP 요청의 행을 그대로 기술                                 |
  | response-code | 응답으로 보내는 HTTP 상태 코드                               |
  | response-size | 응답 엔터티의 Content-Length, 응답으로 반환값이 없으면 값이 0 |

### 21.2.2 혼합 로그 포맷

- 혼합 로그 포맷은 일반 로그 포맷에 추가된 필드 두개를 제외하면 똑같음

  | 필드       | 설명                              |
  | ---------- | --------------------------------- |
  | Referer    | Referrer HTTP 헤더 값             |
  | User-Agent | User-Agent Referer HTTP 헤더의 값 |

### 21.2.3 넷스케이프 확장 로그 포맷

- 넷스케이프의 포맷은 프락시나 웹 캐시 같은 HTTP 애플리케이션과 연관이 있는 여러 환경을 지원하려고 포맷을 확장

- 넷스케이프 확장 로그 포멧은 일반 로그 포맷에 다음의 필드들 추가

  | 필드                     | 설명                                                         |
  | ------------------------ | ------------------------------------------------------------ |
  | proxy-response-code      | 트랜잭션이 프락시를 거칠 경우, 서버에서 프락시로의 HTTP 응답 코드 |
  | proxy-response-size      | 트랜잭션이 프락시를 거칠 경우, 서버가 프락시에 전달하는 응답 엔터티의 Content-Length |
  | client-request-size      | 클라이언트가 프락시로 보내는 요청의 본문이나 엔터티의 Content-Length |
  | proxy-request-size       | 트랜잭션이 프락시를 거칠 경우, <br>프락시가 서버로 보내는 요청의 본문이나 엔터티의 Content-Length |
  | client-request-hdr-size  | 클라이언트 요청 헤더의 바이트 길이                           |
  | proxy-response-hdr-size  | 트랜잭션이 프락시를 거칠 경우, 프락시가 요청자에게 보내는 응답 헤더의 바이트 길이 |
  | proxy-request-hdr-size   | 트랜잭션이 프락시를 거칠 경우, 프락시가 서버로 전송하는 요청 헤더의 바이트 길이 |
  | server-response-hdr-size | 서버 응답 헤더의 바이트 길이                                 |
  | proxy-timestamp          | 트랜잭션이 프락시를 거칠 경우, 요청과 응답이 프락시를 통해 오가는 총 시간(초) |

### 21.2.4 넷스케이프 확장 2 로그 포맷

- 넷스케이프 확장 로그 포맷에서 다음의 필드들 추가

  | 필드                      | 설명                                                         |
  | ------------------------- | ------------------------------------------------------------ |
  | route                     | 프락시가 클라이언트에 요청을 만드는데 사용하는 경로          |
  | client-finish-status-code | 클라이언트의 종료 상태 코드로, <br>클라이언트가 프락시로 보낸 요청이 성공적으로 완료(FIN) 되었는지, 인터럽트에 걸렸는지(INTR) |
  | proxy-finish-status-code  | 프락시의 종료 코드로, <br>프락시가 서버로 보낸 요청이 성공적으로 완료(FIN) 되었는지, 인터럽트에 걸렸는지(INTR) |
  | cache-result-code         | 캐시 결과 코드로, 캐시가 요청에 어떻게 응답했는지 기술       |

- 넷스케이프 애플리케이션은, 다른 많은 HTTP 애플리케이션과 마찬가지로 출력될 로그의 포맷을, 관리자가 수정 가능한 유연한 로그 포맷을 포함한 다양한 로그 포맷을 가짐

- 이런 포맷이 있기 때문에 관리자는 추가적인 설정을 해서 로그에 기록할 HTTP 트랜잭션의  특정 부분을 선택하여 로그 최적화 가능

- 관리자가 포맷을 기호에 맞게 수정 가능하도록 하는 기능이 추가된 것은, 로그에서 얻을 수 있는 정보 중에서 어떤 것을 필요로 하는지 예측하기 어렵기 때문

- 다른 많은 프락시와 서버 역시 로그에서 특정 정보만 추출하는 기능 제공

### 21.2.5 스퀴드(Squid) 프락시 로그 포맷

- 스퀴드는 수년간 오픈 소스 커뮤니티를 통해 확장 및 개선되어 온 프로젝트

- 스퀴드 애플리케이션을 관리하는 데 도움이 되는 수많은 도구들이 개발됨

- 로그 엔트리 포맷

  | 필드               | 설명                                                         |
  | ------------------ | ------------------------------------------------------------ |
  | timestamp          | 요청이 도착한 시간을 리눅스 초로 기술(초 단위)               |
  | time-elapsed       | 요청과 응답이 프락시를 토앻 오고간 총 시간을 밀리초로 기술   |
  | host-ip            | 클라이언트의 호스트 장비 IP 주소                             |
  | result-code/status | result 필드에는 이 요청에 프락시가 어떤 일을 했는지 스퀴드 방식으로 기술<br>code 필드는 프락시가 클라이언트에 보낸 HTTP 응답 코드 |
  | size               | 프락시가 클라이언트에게 보낸 HTTP 응답 헤더와 본문을 포함한 응답의 길이가 바이트 단위로 기술 |
  | method             | 클라이언트 요청의 HTTP 메서드                                |
  | url                | 클라이언트 요청의 URL                                        |
  | rfc931-ident       | 클라이언트에 인증된 사용자 이름                              |
  | hierarchy/from     | 넷스케이프 포맷에 있는 경로(route) 필드 길이, hierarchy 필드에는 프락시가 클라이언트로 요청을 보내면서 거친 경로를 기술 |
  | content-type       | 프락시 응답 엔터티의 Content-Type                            |


## 21.3 적중 계량하기

- 로깅은 클라이언트가 웹서버에 직접 방문했을 때 이런 것들을 추적하는데 사용하기 위해 원 서버에 상세 로그를 저장
- 클라이언트와 서버 사이에 캐시가 있어서, 많은 요청이 서버까지 오지 않고 캐시되어 있는 리소스로 처리되고 끝남
- 하지만, 캐시는 수많은 HTTP 요청을 처리하므로, 요청이 원 서버까지 오지 않더라도 정상적으로 처리 가능해서, 클라이언트가 콘텐츠에 접근했다는 기록을 남기지 않아 결국엔 로그 파일에 누락을 발생 시킴
- 로그 데이터가 유실되기 때문에, 콘텐츠 제공자는 어쩔 수 없이 중요한 페이지의 캐시를 파기
  - 캐시 파기는 콘텐츠 생산자가 의도적으로 특정 콘텐츠가 캐시되지 않게 만드는 것이므로, 이 콘텐의 모든 요청은 원 서버로 감
  - 결국 원 서버는 리소스에 대한 접근 로깅 가능
  - 캐시를 파기시켜 로깅을 가능케 할수 있지만, 요청에 대한 응답 속도 저하와 원 서버와 네트워크의 부하 가중
- 프락시 캐시들은 자체 로그를 유지하기 때문에, 만약 서버가 로그에 접근 가능하거나, 혹은 적어도 얼마나 자주 서버의 콘텐츠가 프락시 캐시에서 제공되는지 확인 가능한 불완전한 방법이라도 있으면 캐시 파기 회피 가능
  - 적중 계량(Git Metering) 규약은 HTTP의 확장으로, 그 문제의 해결책으로 제시 됨
  - 적중 계량 규약에서는 캐시가 정기적으로 캐시 접근 통계를 원 서버에 보고하도록 함

### 21.3.1 개요

- 적중 계량 규약은 캐시와 서버가 접근 정보를 공유하고, 캐시 리소스의 양을 제어 가능한 기초적인 기능에 대한 HTTP 확장 정의
- 적중 계량이 로깅할 때 발생 가능한 문제에 대한 완벽한 해결책은 아니지만, 적어도 서버가 원하는 통계 정보를 받아볼 수 있는 방법

### 21.3.2 Meter 헤더

- 적중 계량 확장은 Meter라는 새로운 헤더 추가

  | 지시자                | 약어 | 주체 | 설명                                                         |
  | --------------------- | ---- | ---- | ------------------------------------------------------------ |
  | will-report-and-limit | w    | 캐시 | 캐시는 사용량을 보고하고 서버가 기술한 모든 사용 제한에 복종 |
  | wont-report           | x    | 캐시 | 캐시는 사용 제한에 복종하지만, 사용량 보고는 하지 않음       |
  | wont-limit            | y    | 캐시 | 캐시는 사용량 보고를 하지만 사용 제한은 없음                 |
  | count                 | c    | 캐시 | '사용 횟수/재사용 횟수' 순으로 정수로 기술하는 보고 지시자   |
  | max-uses              | u    | 서버 | 서버가 캐시를 사용해서 응답 가능한 최대 횟수 기술            |
  | max-resuses           | r    | 서버 | 서버가 캐시를 재사용해서 응답 가능한 최대 횟수 기술          |
  | do-report             | d    | 서버 | 서버가 프락시에게 사용량 보고를 요구                         |
  | dont-report           | e    | 서버 | 서버가 사용량 보고를 원하지 않음                             |
  | timeout               | t    | 서버 | 서버가 리소스를 계량할 때 시간 제한을 거는데 사용<br>캐시는 기술된 타임아웃 시간 정각이나 1분 전후로 보고를 전송해야 함 |
  | wont-ask              | n    | 서버 | 서버는 계량 정보를 원하지 않음                               |

- 클라이언트의 관점에서 요청은 여느 때와 같이 처리되고, 프락시는 서버에 속해있는 리소스를 추적하기 시작

- 그 다음 프락시는 서버에 리소스에 대한 재검사를 함

- 프락시는 서버로 보내는 조건적 요청에 추적하고자 하는 리소스의 정보를 기술

## 21.4 개인 정보 보호에 대해

- 실제 로깅은 서버와 프락시에서 수행하는 관리 기능이므로, 모든 것이 사용자의 트랜잭션에 적용
- 웹 애플리케이션 개발자와 관리자는 사용자의 HTTP 트랜잭션을 추적하고 있음을 유념해야 함
  - 사용자가 읽는 정보를 통해 사용자에 관한 많은 정보 수집 가능
  - 이 정보는 나쁜 목적으로 사용 가능성 존재
  - 그러므로 로깅하는 웹 서버와 프락시는 최종 사용자의 개인 정보를 보호하는데 신경을 많이 써야 함
- 관리자는 사람들의 트랜잭션을 감시하고 있다는 사실을 공지해야 함(쿠키 수집 허용 등)
- 로깅은 관리자와 개발자에게 유용한 도구지만 로깅을 당하는 사용자들의 인지나 허가가 없다면 사생활 침해라는걸 유념해야 함
