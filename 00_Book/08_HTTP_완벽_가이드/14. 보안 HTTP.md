# 14. 보안 HTTP

## 14.1 HTTP를 안전하게 만들기

- 중요한 트랙젝션을 위해서는, HTTP와 디지털 암호화 기술을 결합해야 함
- HTTP의 보안 버전은 효율적이고, 이식성이 좋아야하고, 관리가 쉬워야 하며, 현실 세계의 변화에 대한 적응력이 좋아햐 함
- 다음의 사항을 제공 가능한 HTTP 보안 기술 필요
  - 서버 인증 : 클라이언트는 올바른 서버와 통신하는지 인지
  - 클라이언트 인증 : 서버는 올바른 클라이언트와 통신하는지 인지
  - 무결성 : 데이터가 위조되는 것으로부터 안전해야 함
  - 암호화 : 도청에 대한 걱정 없이 통신 가능해야 함
  -  효율 : 낮은 사양의 서버나 클라이언트에서도 이용 가능하도록 알고리즘이 충분히 빨라야 함
  - 편재성(Uniquity) : 프로토콜은 거의 모든 클라이언트와 서버에서 지원되야 함
  - 관리상 확장성 : 누구든 어디서든 즉각적인 보안 통신이 가능해야 함
  - 적응성 : 현재 알려진 최선의 보안 방법을 지원해야 함
  - 사회적 생존성 : 사회의 문화적, 정치적 요구를 만족해야 함

### 14.1.1 HTTPS

- HTTPS는 HTTP를 안전하게 만드는 방식 중에서 가장 인기 있음
- HTTP를 사용할 때, **모든 HTTP 요청과 응답 데이터는 네트워크로 보내지기 전에 암호화**
- HTTPS는 **HTTP의 하부에 전송 레벨 암호 보안 계층을 제공함으로써 동작**
  - 보안 계층은 전전 소켓 계층(Secure Sockets Layer, SSL) 혹은 그를 계승한 전송 계층 보안(Transport Layer Security, TLS)을 이용
- 어려운 인코딩 및 디코딩 작업은 대부분 SSL 라이브러리 안에서 일어나기 때문에, HTTPS를 사용하기 위해 로직을 크게 변경 불필요
- 대부분의 경우, TCP IO 호출을 SSL 호출로 대체하고, 보안 정보를 설정하고 관리하기 위한 몇 가지 호출을 추가해 줌

## 14.2 디지털 암호학

### 14.2.1 비밀 코드의 기술과 과학

- 암호법은 단순히 3자가 볼 수 없도록 메시지를 암호화하는 것뿐 아니라, 메시지 변조 방지를 위해 사용
- 어떤 메시지나 트랜젝션의 소유자임을 증명하는 데도 사용 가능

### 14.2.2 암호(cipher)

- 암호 : 메시지를 인코딩하는 특정한 방법과 나중에 그 비밀 메시지를 디코딩하는 방법
- 평문 : 인코딩되기 전의 원본 메시지
- 암호문 : 암호가 적용되어 코딩된 메시지

### 14.2.3 암호 기계

- 기술이 진보하면서, 보다 복잡한 암호로 메시지를 빠르고 정확하게 인코딩하고 디코딩하는 기계를 만들기 시작

### 14.2.4 키가 있는 암호

- 코드 알고리즘과 기계를 해커가 탈취할 수 있기 때문에, 대부분의 기계들에는 암호의 동작방식을 변경할 수 있는 다이얼이 있음
- 누군가 기계를 훔치더라도, 올바른 키 값 없이는 디코더가 동작하지 않음

### 14.2.5 디지털 암호

- 디지털 계산의 도래로 인한 두 가지 주요한 발전
  - 속도 및 기능이 크게 발전함으로써, 복잡한 인코딩과 디코딩 알고리즘이 가능해짐
  - 매우 큰 기를 지원하는 것이 가능해짐
    - 단일 암호 알고리즘으로 키의 값마다 다른 수조 개의 가상 암호 알고맂므을 만들어 낼 수 있음
    - 키가 길수록 인코딩의 많은 조합이 가능해지고 무작위로 추측한 키에 의한 크래킹이 어려워짐

## 14.3 대칭키 암호법

- 인코딩할 때 사용하는 키가 디코딩 할때의 키가 같음
- DES, Triple-DES, RC2, RC4

### 14.3.1 키 길이와 열거 공격(Enumeration Attack)

- 대부분의 경우, 인코딩 및 디코딩 알고리즘은 공개적으로 알려져 있으므로, 키만이 유일한 비밀
- 열거 공격 : 무차별로 모든 키 값을 대입해보는 공격
- 가능한 키값의 개수는 키가 몇 비트이며 얼마나 많은 키가 유효한지에 달려있음
- 대칭키 암호에서는 보통 모든 키 값이 유효함
  - 2^비트수 만큼의 가짓수가 가능
  - 평범한 대칭키 암호에서, 40비트 키는 작고 중요하지 않은 업무에는 충분하지만, 오늘날의 사양으로는 쉽게 뚫림
  - 128비트 키를 사용한 대칭키 암호는 매우 강력한 것으로 간주

### 14.3.2 공유키 발급하기

- 대칭키 암호의 단점 중 하나는 발송자와 수신자가 서로 대화하려면 둘 다 공유키를 가져야 한다는 것
- 모든 사용자에게 비밀 키를 발급해야 한다면, 수백, 수천개의 키를 생성하고 기억해야 함
- 관리자의 입장에서 이것은 곤란함

## 14.4 공개키 암호법

- 하나의 인코딩/디코딩 키를 사용하는 대신, 공개키 암호 방식은 두 개의 비대칭 키를 사용
- 하나는 인코딩하기 위한 것이며, 다른 하나는 디코딩하기 위한 것
- 인코딩 키는 모두를 위해 공개되어 있지만, 디코딩 키는 오직 당사자만 알고 있음

- 공개키 암호 방식은 대칭 키의 쌍이 폭발적으로 증가하는 것을 피할 수 있음
- 공개키 암호화 기술은 보안 프로토콜을 전 세계의 모든 컴퓨터 사용자에게 적용하는 것을 가능케 함

### 14.4.1 RSA

### 14.4.2 혼성 암호 체계와 세션 키

- 비대칭 공개키 암호 방식은 누구나 공개키만 알면 그 키에 대응되는 공개 서버에 안전한게 메세지를 보낼 수 있음
- 공개키 암호 방식의 알고리즘은 계산이 느린 경향이 존재
- 실제로는 대칭과 비대칭 방식을 섞은 것이 쓰임
  - 노드들 사이의 안전한 의사소통 채널을 수립할 때는 편리하게 공개 키 암호를 사용하고
  - 만들어진 안전한 채널을 통해 임시의 무작위 대칭 키를 생성하고 교환하여 나머지 데이터를 암호화할 때 대칭키 사용

## 14.5 디지털 서명

### 14.5.1 서명은 암호 체크섬

- 디지털 서명은 메시지에 붙어있는특별한 암호 체크섬
  - 서명은 메시지를 작성한 저자가 누군지 알려줌
    - 저자는 저자의 극비 개인 키를 갖고 있기 때문에, 오직 저자만이 체크섬 계산 가능
    - 체크섬은 개인 '서명' 처럼 동작
  - 서명은 메시지 위조를 방지함
    - 공격자가 송신 중인 메시지를 수정했따면, 체크섬은 더 이상 그 메시지와 맞지 않음
    - 체크섬은 저자의 비밀 개인 키에 관련되어 있기 때문에, 올바른 체크섬 날조 불가능
- 디지털 서명은 비대칭 공개키에 의해 생성

## 14.6 디지털 인증서

### 14.6.1 인증서의 내부

- 디지털 인증서에는 '인증 기관'에 의해 디지털 서명된 정보의 집합이 담김
- 디지털 인증서에 포함되는 사항
  - 대상의 이름(사람, 서버, 조직)
  - 유효 기간
  - 인증서 발급자
  - 인증서 발급자의 디지털 서명
- 디지털 인증서는 대상과 사용된 서명 알고리즘에 대한 서술적인 정보뿐 아니라 대상의 공개키도 포함

### 14.6.2 서버 인증을 위해 인증서 사용

- 사용자가 HTTPS를 통한 안전한 웹 트랜젝션을 싲가할 때, 최신 브라우저는 자동으로 서버에서 디지털 인증서를 가져옴
- 만약 서버가 인증서를 갖고 있지 않다면, 보안 커넥션은 실패
- 브라우저가 인증서를 받으면, 서명 기관을 검사
  - 신뢰할만한 서명 기관이라면 브라우저는 그것의 공개키를 이미 알고 있음
  - 브라우저는 여러 서명 기관의 인증서가 미리 포함된채 배포됨
  - 만약 서명 기관이 모르는 곳이라면, 브라우저는 사용자가 서명 기관을 신뢰하는지 확인함

## 14.7 HTTPS의 세부사항

### 14.7.1 HTTPS 개요

- HTTPS는 그냥 보안 전송 계층을 통해 전송되는 HTTP
- HTTP 메시지를 TCP를 보내기 전에 먼저 암호화하는 보안 계층으로 보냄

- 오늘날, HTTPS의 보안 계층은, SSL과 현대적인 대체품인 TLS로 구현됨

### 14.7.2 HTTPS 스킴

- 보안이 되는 HTTPS 프로토콜에서 URL의 스킴 접두사는 https
- 클라이언트는 웹 리소스에 대한 트랜젝션 수행을 요청받으면 URL의 스킴을 검사
  - URL이 http 스킴을 갖고 있다면, 80번 포트에 연결하고 평범한 HTTP 명령 전송
  - https 스킴을 갖고 있다면, 443번 포트에 연결하고 서버와 바이너리 포멧으로 매개변수를 교환하면서 '핸드셰이크'하고, 암호화된 HTTP 명령이 뒤를 이음

### 14.7.3 보안 전송 셋업

- 클라이언트는 먼저 웹 서버의 443 포트로 연결
- TCP 연결이 된 후, 클라이언트와 서버는 암호법 매개변수와 교환 키를 협상하면서 SSL 계층 초기화
- 핸드셰이크가 완료되면 SSL 초기화는 완료되며, 클라이언트는 요청 메시지를 보안 계층에 보냄
- 이 메시지는 TCP로 보내지기 전에 암호화

### 14.7.4 SSL 핸드셰이크

- 암호화된 HTTP 메시지를 보낼 수 있게 되기 전에, 클라이언트와 서버는 SSL 핸드셰이크를 할 필요 있음
- 핸드셰이크는 다음과 같음
  - 프로토콜 버전 번호 교환
  - 양쪽이 알고 있는 암호 선택
  - 양쪽의 신원을 인증
  - 채널을 암호화하기 위한 임시 세션 키 생성

### 14.7.5 서버 인증서

- 보안 HTTPS 트랜젝션은 항상 서버 인증서를 요구
- 사용자와 사용자의 클라이언트 소프트웨어는 모든 것이 믿을 만한 것인지 확인하기 위해 인증서 검증 가능

### 14.7.6 사이트 인증서 검사

- 날짜 검사
  - 인증서가 유효함을 확인하기 위해 인증서의 시작 및 종료일을 검사
- 서명자 신뢰도 검사
  - 모든 인증서는 서버를 보증하는 어떤 인증 기관(Certificate Authority, CA)에 의해 서명
  - 브라우저는 신뢰할 만한 서명 기관의 목록을 포함한 채로 배포됨
  - 잘 알려져 있지 않은 인증기관으로부터 서명된 인증서를 받으면, 브라우저는 경고를 띄움
- 서명 검사
  - 한번 서명 기관이 믿을 만하다고 판단되면, 브라우저는 서명 기관의 공개키를 서명에 적용하여 그의 체크섬과 비교해봄으로써 인증서의 무결성 검사
- 사이트 신원 검사
  - 서버가 누군가 인증서를 복사하거나 트래픽을 가로채는 것을 방지하기 위해, 인증서의 도메인이 서버의 도메인과 맞는지 검사
  - 호스트명이 인증서의 신원과 맞지 않는다면, 클라이언트는 반드시 사용자에게 알리거나 커넥션을 끊어야 함

### 14.7.7 가상 호스팅과 인증서

- 몇몇 인기 있는 웹 서버 프로그램은 오직 하나의 인증서만을 지원
- 만약 사용자가 인증서의 이름과 맞지 않는 가상 호스트 명에 도착했다면 경고 상자가 나타남
- 이러한 문제를 피하기 위해 호스트 소유자는 보안 트랜젝션을 시작하는 모든 사용자를 리다이렉트함
