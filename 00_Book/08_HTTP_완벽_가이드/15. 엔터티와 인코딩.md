# 15. 엔터티와 인코딩

## 15.1 메시지는 컨테이너, 엔터티는 화물

- HTTP 메시지를 인터넷 운송 시스템의 컨테이너라 하면, 엔터티는 실질적인 화물

### 15.1.1 엔터티 본문

- 엔터티 본문은 가공되지 않은 데이터만을 담고 있음
- 엔터티 본문은은  가공되지 않았기 때문에 엔터티 헤더는 그 의미에 대해 설명할 필요가 있음
- 엔터티 본문은 헤더 필드의 끝을 의미하는 빈 CRLF(\r\n) 줄 바로 다음부터 시작

## 15.2 Content-Length: 엔터티의 길이

- Content-Length 헤더는 메시지의 엔터티 본문의 크기를 바이트 단위로 나타냄
- 어떻게 인코딩 되었든 상관없이 크기 표현 가능
- Content-Length 헤더는, 메시지를 청크 인코딩으로 전송하지 않는 이상, 필수적으로 있어야 함
- 서버 충돌로 인해 메시지가 잘렸는지 감지하고자 할 때와 커넥션을 공유하는 메시지를 올바르게 분할하고자 할 때 필요

### 15.2.1 잘림 검출

- 옛날 버전의 HTTP는 커넥션이 닫힌 것을 보고 메시지가 끝났음을 인지
- Content-Length가 없다면 클라이언트는 커넥션이 정상적으로 닫힌 것인지 전송 중 에러가 발생한 건지 구분하지 못함

- 메시지가 잘렸다는 것을 인식하지 못하면, 캐시는 결함이 있는 콘텐츠를 저장하고 계속해서 제공하게 됨
- 잘린 메시지를 캐싱하는 위험을 줄이기 위해, 프락시 서버는 Content-Length 헤더를 갖고 있지 않은 HTTP 본문은 보탱 캐시하지 않음

### 15.2.2 잘못된 Content-Length

- 잘못된 값을 담고 있을 경우 아예 빠진 것보다도 큰 피해를 유발 가능
- HTTP/1.1 사용자 에이전트는 잘못된 길이를 받고 인지했을 때 사용자에게 알려주게 됨

### 15.2.3 Content-Length와 지속 커넥션(Persistent Connection)

- Content-Length는 지속 커넥션을 위해 필수
- Content-Length 헤더는 클라이언트에게 메시지 하나가 어디서 끝나고 다음 시작은 어디인지 알려줌
- 커넥션이 지속적이기 때문에, 클라이언트가 커넥션이 닫힌 위치를 근거로 메시지의 끝을 인식하는 것은 불가능
- HTTP 애플리케이션은 Content-Length 헤더 없이는 엔터티 본문과 내용을 구분 불가능

### 15.2.4 콘텐츠 인코딩

- HTTP는 보안을 강화하거나 압축을 통해 공간을 절약 가능하도록, 엔터티 본문을 인코딩 가능케 함
- 본문의 콘텐츠가 인코딩되어 있다면, Content-Length 헤더는 인코딩된 본문의 길이를 바이트 단위로 정의

### 15.2.5 엔터티 본문 길이 판별을 위한 규칙

1. 본문을 갖는 것이 허용되지 않는 특정 타입의 HTTP 메시지에서는, 본문 계산을 위한 헤더가 무시
2. 메시지가 Transfer-Encoding헤더를 포함하고 있다면, 메시지가 커넥션이 닫혀서 끝나지 않는 이상 엔터티는 '0 바이트 청크'라 불리는 특별한 패턴으로 끝나야 함
3. 메시지가 Content-Length 헤더를 갖는다면, Transfer-Encoding 헤더가 존재하지 않는 이상 Content-Length값은 본문의 길이를 담게 됨
4. 메시지가 'multipart/byteranges' 미디어 타입을 사용하고 엔터티 길이가 별도로 정의되지 않았다면, 멀티파트 메시지의 각 부분은 각자가 스스로의 크기를 정의
5. 위의 어떤 규칙도 해당되지 않는다면, 엔터티는 커넥션이 닫힐 때 끝남
6. HTTP/1.0 애플리케이션과의 호환을 위해, 엔터티 본문을  갖고 있는 HTTP/1.1 요청은 반드시 유효한 Content-Length 헤더를 가짐

## 15.3 엔터티 요약

- 엔터티 본문 데이터에 대한 의도하지 않은 변경을 감지하기 위해, 최초 엔터티가 생성될 때 송신자는 데이터에 대한 체크섬 생성 가능
- 수신자는 모든 의도하지 않은 엔터티의 변경을 잡아내기 위해 그 체크섬으로 기본적인 검사 가능
- Content-MD5 헤더는 서버가 엔터티 본문에 MD5 알고리즘을 적용한 결과를 보내기 위해 사용
  - MD5 알고리즘: 128비트 암호화 해시 함수, 주로 프로그램이나 파일이 원본 그대로인지를 확인하는 무결성 검사에 사용
- 메시지 무결성 검사에 더해, MD5는 문서의 위치를 빠르게 알아내고 콘텐츠의 중복 저장을 방지 가능
- 이런 활용 가치에도 불구하고, Content-MD5 헤더는 자주 전송되지 않음

## 15.4 미디어 타입과 차셋(Charset)

- Content-Type 헤더 필드는 엔터티 본문의 MIME 타입을 기술

- Content-Type의 값은 인터넷 할당 번호 관리 기관(Internet Assigned Numbers Authority, IANA)에 등록된 표준화된 MIME 타입
- Content-Type 헤더가 원본 엔터티 본문의 미디어 타입을 명시한다는 것은 중요함

### 15.4.1 텍스트 매체를 위한 문자 인코딩

- Content-Type 헤더는 내용 유형을 더 자세히 지정하기 위한 선택적인 매개변수도 지원

- 엔터티의 비트 집합을 텍스트 파일의 글자들로 변환하기 위한 'charset' 매개변수가 대표적

  `Content-Type: text/html; charset=iso-8859-4`

### 15.4.2 멀티파트 미디어 타입

- MIME '멀티파트' 이메일 메시지는 서로 붙어있는 여러 개의 메시지를 포함하며, 하나의 복합 메시지로 보내짐
- 각 구성요소는 자족적으로 자신에 대해 서술하는 헤더 포함
- HTTP는 멀티파트 본문도 지원하지만, 일반적으로는 폼을 채워서 제출할 때와 문서의 일부분을 실어 나르는 범위 응답을 할때 사용

### 15.4.3 멀티파트 폼 제출

- HTTP 폼을 채워서 제출하면, 가변 길이 텍스트 필드와 업로드 될 객체는 각각이 멀티파트 본문을 구성하는 하나의 파트가 되어 보내짐
- HTTP는 그러한 요청을 `Content-Type: multipart/form-data`나 `Content-Type: multipart/mixed` 헤더에 본문을 함께 보냄

### 15.4.4 멀티파트 범위 응답

- 범위 응답에 대한 HTTP 응답 또한 멀티파트가 될 수도 있음
- `Content-Type: multipart/byteranges` 헤더 및 각각 다른 범위를 담고 있는 멀티파트 본문이 함께 옴