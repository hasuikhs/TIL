# 15. 엔터티와 인코딩

## 15.1 메시지는 컨테이너, 엔터티는 화물

- HTTP 메시지를 인터넷 운송 시스템의 컨테이너라 하면, 엔터티는 실질적인 화물

### 15.1.1 엔터티 본문

- 엔터티 본문은 가공되지 않은 데이터만을 담고 있음
- 엔터티 본문은은  가공되지 않았기 때문에 엔터티 헤더는 그 의미에 대해 설명할 필요가 있음
- 엔터티 본문은 헤더 필드의 끝을 의미하는 빈 CRLF(\r\n) 줄 바로 다음부터 시작

## 15.2 Content-Length: 엔터티의 길이

- Content-Length 헤더는 메시지의 엔터티 본문의 크기를 바이트 단위로 나타냄
- 어떻게 인코딩 되었든 상관없이 크기 표현 가능
- Content-Length 헤더는, 메시지를 청크 인코딩으로 전송하지 않는 이상, 필수적으로 있어야 함
- 서버 충돌로 인해 메시지가 잘렸는지 감지하고자 할 때와 커넥션을 공유하는 메시지를 올바르게 분할하고자 할 때 필요

### 15.2.1 잘림 검출

- 옛날 버전의 HTTP는 커넥션이 닫힌 것을 보고 메시지가 끝났음을 인지
- Content-Length가 없다면 클라이언트는 커넥션이 정상적으로 닫힌 것인지 전송 중 에러가 발생한 건지 구분하지 못함

- 메시지가 잘렸다는 것을 인식하지 못하면, 캐시는 결함이 있는 콘텐츠를 저장하고 계속해서 제공하게 됨
- 잘린 메시지를 캐싱하는 위험을 줄이기 위해, 프락시 서버는 Content-Length 헤더를 갖고 있지 않은 HTTP 본문은 보탱 캐시하지 않음

### 15.2.2 잘못된 Content-Length

- 잘못된 값을 담고 있을 경우 아예 빠진 것보다도 큰 피해를 유발 가능
- HTTP/1.1 사용자 에이전트는 잘못된 길이를 받고 인지했을 때 사용자에게 알려주게 됨

### 15.2.3 Content-Length와 지속 커넥션(Persistent Connection)

- Content-Length는 지속 커넥션을 위해 필수
- Content-Length 헤더는 클라이언트에게 메시지 하나가 어디서 끝나고 다음 시작은 어디인지 알려줌
- 커넥션이 지속적이기 때문에, 클라이언트가 커넥션이 닫힌 위치를 근거로 메시지의 끝을 인식하는 것은 불가능
- HTTP 애플리케이션은 Content-Length 헤더 없이는 엔터티 본문과 내용을 구분 불가능

### 15.2.4 콘텐츠 인코딩

- HTTP는 보안을 강화하거나 압축을 통해 공간을 절약 가능하도록, 엔터티 본문을 인코딩 가능케 함
- 본문의 콘텐츠가 인코딩되어 있다면, Content-Length 헤더는 인코딩된 본문의 길이를 바이트 단위로 정의

### 15.2.5 엔터티 본문 길이 판별을 위한 규칙

1. 본문을 갖는 것이 허용되지 않는 특정 타입의 HTTP 메시지에서는, 본문 계산을 위한 헤더가 무시
2. 메시지가 Transfer-Encoding헤더를 포함하고 있다면, 메시지가 커넥션이 닫혀서 끝나지 않는 이상 엔터티는 '0 바이트 청크'라 불리는 특별한 패턴으로 끝나야 함
3. 메시지가 Content-Length 헤더를 갖는다면, Transfer-Encoding 헤더가 존재하지 않는 이상 Content-Length값은 본문의 길이를 담게 됨
4. 메시지가 'multipart/byteranges' 미디어 타입을 사용하고 엔터티 길이가 별도로 정의되지 않았다면, 멀티파트 메시지의 각 부분은 각자가 스스로의 크기를 정의
5. 위의 어떤 규칙도 해당되지 않는다면, 엔터티는 커넥션이 닫힐 때 끝남
6. HTTP/1.0 애플리케이션과의 호환을 위해, 엔터티 본문을  갖고 있는 HTTP/1.1 요청은 반드시 유효한 Content-Length 헤더를 가짐

## 15.3 엔터티 요약

- 엔터티 본문 데이터에 대한 의도하지 않은 변경을 감지하기 위해, 최초 엔터티가 생성될 때 송신자는 데이터에 대한 체크섬 생성 가능
- 수신자는 모든 의도하지 않은 엔터티의 변경을 잡아내기 위해 그 체크섬으로 기본적인 검사 가능
- Content-MD5 헤더는 서버가 엔터티 본문에 MD5 알고리즘을 적용한 결과를 보내기 위해 사용
  - MD5 알고리즘: 128비트 암호화 해시 함수, 주로 프로그램이나 파일이 원본 그대로인지를 확인하는 무결성 검사에 사용
- 메시지 무결성 검사에 더해, MD5는 문서의 위치를 빠르게 알아내고 콘텐츠의 중복 저장을 방지 가능
- 이런 활용 가치에도 불구하고, Content-MD5 헤더는 자주 전송되지 않음

## 15.4 미디어 타입과 차셋(Charset)

- Content-Type 헤더 필드는 엔터티 본문의 MIME 타입을 기술

- Content-Type의 값은 인터넷 할당 번호 관리 기관(Internet Assigned Numbers Authority, IANA)에 등록된 표준화된 MIME 타입
- Content-Type 헤더가 원본 엔터티 본문의 미디어 타입을 명시한다는 것은 중요함

### 15.4.1 텍스트 매체를 위한 문자 인코딩

- Content-Type 헤더는 내용 유형을 더 자세히 지정하기 위한 선택적인 매개변수도 지원

- 엔터티의 비트 집합을 텍스트 파일의 글자들로 변환하기 위한 'charset' 매개변수가 대표적

  `Content-Type: text/html; charset=iso-8859-4`

### 15.4.2 멀티파트 미디어 타입

- MIME '멀티파트' 이메일 메시지는 서로 붙어있는 여러 개의 메시지를 포함하며, 하나의 복합 메시지로 보내짐
- 각 구성요소는 자족적으로 자신에 대해 서술하는 헤더 포함
- HTTP는 멀티파트 본문도 지원하지만, 일반적으로는 폼을 채워서 제출할 때와 문서의 일부분을 실어 나르는 범위 응답을 할때 사용

### 15.4.3 멀티파트 폼 제출

- HTTP 폼을 채워서 제출하면, 가변 길이 텍스트 필드와 업로드 될 객체는 각각이 멀티파트 본문을 구성하는 하나의 파트가 되어 보내짐
- HTTP는 그러한 요청을 `Content-Type: multipart/form-data`나 `Content-Type: multipart/mixed` 헤더에 본문을 함께 보냄

### 15.4.4 멀티파트 범위 응답

- 범위 응답에 대한 HTTP 응답 또한 멀티파트가 될 수도 있음
- `Content-Type: multipart/byteranges` 헤더 및 각각 다른 범위를 담고 있는 멀티파트 본문이 함께 옴

## 15.5 콘텐츠 인코딩

- HTTP 애플리케이션은 때때로 콘텐츠를 보내기 전에 인코딩을 하려고 함
- 콘텐츠 인코딩은 발송하는 쪽에서 콘텐츠에 적용, 인코디잉 끝난 데이터는 엔터티 본문에 담아 수신자에게 전송

### 15.5.1 콘텐츠 인코딩 과정

1. 웹 서버가 원본 Content-Type과 Content-Length 헤더를 수반한 원본 응답 메시지 생성

2. 콘텐츠 인코딩 서버가 인코딩 메시지 생성, 인코딩된 메시지는 Content-Type은 같지만 Content-Length는 다름

   콘텐츠 인코딩 서버는 Content-Encoding 헤더를 인코딩된 메시지에 추가하여, 수신측에 디코딩 가능케 함

3. 수신 측은 인코딩된 메시지를 받아서 디코딩하고 원본 획득

### 15.5.2 콘텐츠 인코딩 유형

- HTTP는 몇 가지 표준 콘텐츠 인코딩 유형을 정의하고 확장 인코딩으로 인코딩을 추가하는 것을 허용
- 인코딩은 각 콘텐츠 인코딩 알고리즘에 고유한 토큰을 할당하는 IANA를 통해 표준화

| 콘텐츠 인코딩 값 | 설명                                                         |
| ---------------- | ------------------------------------------------------------ |
| gzip             | 엔터티에 GNU zip 인코딩이 적용되었음을 의미                  |
| compress         | 엔터티에 대해 유닉스 압축 프로그램인 'compress'가 실행되었음을 의미 |
| deflate          | 엔터티가 zlib 포멧으로 압축되었음을 의미                     |
| identity         | 엔터티에 어떤 인코딩도 수행되지 않았음을 의미. Content-Encoding 헤더가 없다면 이 값으로 간주 |

- gzip이 일반적으로 가장 효율적이고 가장 널리 쓰이는 압축 알고리즘

### 15.5.3 Accept-Encoding 헤더

- 클라이언트가 해독 불가능한 방법으로 서버가 콘텐츠를 인코딩하는 것을 지양
- 클라이언트가 지원하는 인코딩 목록을 Accept-Encoding 요청 헤더를 전달
- Accept-Encoding 헤더를 포함하지 않는다면, 서버는 클라이언트가 어떤 인코딩이든 받을 수 있는 것으로 간주

- 클라이언트는 각 인코딩에 Q(quality) 값을 매개 변수로 선호도를 나타낼 수 있음 (0.0 ~ 1.0)