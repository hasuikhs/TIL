# 15. 엔터티와 인코딩

## 15.1 메시지는 컨테이너, 엔터티는 화물

- HTTP 메시지를 인터넷 운송 시스템의 컨테이너라 하면, 엔터티는 실질적인 화물

### 15.1.1 엔터티 본문

- 엔터티 본문은 가공되지 않은 데이터만을 담고 있음
- 엔터티 본문은은  가공되지 않았기 때문에 엔터티 헤더는 그 의미에 대해 설명할 필요가 있음
- 엔터티 본문은 헤더 필드의 끝을 의미하는 빈 CRLF(\r\n) 줄 바로 다음부터 시작

## 15.2 Content-Length: 엔터티의 길이

- Content-Length 헤더는 메시지의 엔터티 본문의 크기를 바이트 단위로 나타냄
- 어떻게 인코딩 되었든 상관없이 크기 표현 가능
- Content-Length 헤더는, 메시지를 청크 인코딩으로 전송하지 않는 이상, 필수적으로 있어야 함
- 서버 충돌로 인해 메시지가 잘렸는지 감지하고자 할 때와 커넥션을 공유하는 메시지를 올바르게 분할하고자 할 때 필요

### 15.2.1 잘림 검출

- 옛날 버전의 HTTP는 커넥션이 닫힌 것을 보고 메시지가 끝났음을 인지
- Content-Length가 없다면 클라이언트는 커넥션이 정상적으로 닫힌 것인지 전송 중 에러가 발생한 건지 구분하지 못함

- 메시지가 잘렸다는 것을 인식하지 못하면, 캐시는 결함이 있는 콘텐츠를 저장하고 계속해서 제공하게 됨
- 잘린 메시지를 캐싱하는 위험을 줄이기 위해, 프락시 서버는 Content-Length 헤더를 갖고 있지 않은 HTTP 본문은 보탱 캐시하지 않음

### 15.2.2 잘못된 Content-Length

- 잘못된 값을 담고 있을 경우 아예 빠진 것보다도 큰 피해를 유발 가능
- HTTP/1.1 사용자 에이전트는 잘못된 길이를 받고 인지했을 때 사용자에게 알려주게 됨

### 15.2.3 Content-Length와 지속 커넥션(Persistent Connection)

- Content-Length는 지속 커넥션을 위해 필수
- Content-Length 헤더는 클라이언트에게 메시지 하나가 어디서 끝나고 다음 시작은 어디인지 알려줌
- 커넥션이 지속적이기 때문에, 클라이언트가 커넥션이 닫힌 위치를 근거로 메시지의 끝을 인식하는 것은 불가능
- HTTP 애플리케이션은 Content-Length 헤더 없이는 엔터티 본문과 내용을 구분 불가능

### 15.2.4 콘텐츠 인코딩

- HTTP는 보안을 강화하거나 압축을 통해 공간을 절약 가능하도록, 엔터티 본문을 인코딩 가능케 함
- 본문의 콘텐츠가 인코딩되어 있다면, Content-Length 헤더는 인코딩된 본문의 길이를 바이트 단위로 정의

### 15.2.5 엔터티 본문 길이 판별을 위한 규칙

1. 본문을 갖는 것이 허용되지 않는 특정 타입의 HTTP 메시지에서는, 본문 계산을 위한 헤더가 무시
2. 메시지가 Transfer-Encoding헤더를 포함하고 있다면, 메시지가 커넥션이 닫혀서 끝나지 않는 이상 엔터티는 '0 바이트 청크'라 불리는 특별한 패턴으로 끝나야 함
3. 메시지가 Content-Length 헤더를 갖는다면, Transfer-Encoding 헤더가 존재하지 않는 이상 Content-Length값은 본문의 길이를 담게 됨
4. 메시지가 'multipart/byteranges' 미디어 타입을 사용하고 엔터티 길이가 별도로 정의되지 않았다면, 멀티파트 메시지의 각 부분은 각자가 스스로의 크기를 정의
5. 위의 어떤 규칙도 해당되지 않는다면, 엔터티는 커넥션이 닫힐 때 끝남
6. HTTP/1.0 애플리케이션과의 호환을 위해, 엔터티 본문을  갖고 있는 HTTP/1.1 요청은 반드시 유효한 Content-Length 헤더를 가짐