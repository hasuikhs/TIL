# 15. 엔터티와 인코딩

## 15.1 메시지는 컨테이너, 엔터티는 화물

- HTTP 메시지를 인터넷 운송 시스템의 컨테이너라 하면, 엔터티는 실질적인 화물

### 15.1.1 엔터티 본문

- 엔터티 본문은 가공되지 않은 데이터만을 담고 있음
- 엔터티 본문은은  가공되지 않았기 때문에 엔터티 헤더는 그 의미에 대해 설명할 필요가 있음
- 엔터티 본문은 헤더 필드의 끝을 의미하는 빈 CRLF(\r\n) 줄 바로 다음부터 시작

## 15.2 Content-Length: 엔터티의 길이

- Content-Length 헤더는 메시지의 엔터티 본문의 크기를 바이트 단위로 나타냄
- 어떻게 인코딩 되었든 상관없이 크기 표현 가능
- Content-Length 헤더는, 메시지를 청크 인코딩으로 전송하지 않는 이상, 필수적으로 있어야 함
- 서버 충돌로 인해 메시지가 잘렸는지 감지하고자 할 때와 커넥션을 공유하는 메시지를 올바르게 분할하고자 할 때 필요

### 15.2.1 잘림 검출

- 옛날 버전의 HTTP는 커넥션이 닫힌 것을 보고 메시지가 끝났음을 인지
- Content-Length가 없다면 클라이언트는 커넥션이 정상적으로 닫힌 것인지 전송 중 에러가 발생한 건지 구분하지 못함

- 메시지가 잘렸다는 것을 인식하지 못하면, 캐시는 결함이 있는 콘텐츠를 저장하고 계속해서 제공하게 됨
- 잘린 메시지를 캐싱하는 위험을 줄이기 위해, 프락시 서버는 Content-Length 헤더를 갖고 있지 않은 HTTP 본문은 보탱 캐시하지 않음

### 15.2.2 잘못된 Content-Length

- 잘못된 값을 담고 있을 경우 아예 빠진 것보다도 큰 피해를 유발 가능
- HTTP/1.1 사용자 에이전트는 잘못된 길이를 받고 인지했을 때 사용자에게 알려주게 됨

### 15.2.3 Content-Length와 지속 커넥션(Persistent Connection)

- Content-Length는 지속 커넥션을 위해 필수
- Content-Length 헤더는 클라이언트에게 메시지 하나가 어디서 끝나고 다음 시작은 어디인지 알려줌
- 커넥션이 지속적이기 때문에, 클라이언트가 커넥션이 닫힌 위치를 근거로 메시지의 끝을 인식하는 것은 불가능
- HTTP 애플리케이션은 Content-Length 헤더 없이는 엔터티 본문과 내용을 구분 불가능

### 15.2.4 콘텐츠 인코딩

- HTTP는 보안을 강화하거나 압축을 통해 공간을 절약 가능하도록, 엔터티 본문을 인코딩 가능케 함
- 본문의 콘텐츠가 인코딩되어 있다면, Content-Length 헤더는 인코딩된 본문의 길이를 바이트 단위로 정의

### 15.2.5 엔터티 본문 길이 판별을 위한 규칙

1. 본문을 갖는 것이 허용되지 않는 특정 타입의 HTTP 메시지에서는, 본문 계산을 위한 헤더가 무시
2. 메시지가 Transfer-Encoding헤더를 포함하고 있다면, 메시지가 커넥션이 닫혀서 끝나지 않는 이상 엔터티는 '0 바이트 청크'라 불리는 특별한 패턴으로 끝나야 함
3. 메시지가 Content-Length 헤더를 갖는다면, Transfer-Encoding 헤더가 존재하지 않는 이상 Content-Length값은 본문의 길이를 담게 됨
4. 메시지가 'multipart/byteranges' 미디어 타입을 사용하고 엔터티 길이가 별도로 정의되지 않았다면, 멀티파트 메시지의 각 부분은 각자가 스스로의 크기를 정의
5. 위의 어떤 규칙도 해당되지 않는다면, 엔터티는 커넥션이 닫힐 때 끝남
6. HTTP/1.0 애플리케이션과의 호환을 위해, 엔터티 본문을  갖고 있는 HTTP/1.1 요청은 반드시 유효한 Content-Length 헤더를 가짐

## 15.3 엔터티 요약

- 엔터티 본문 데이터에 대한 의도하지 않은 변경을 감지하기 위해, 최초 엔터티가 생성될 때 송신자는 데이터에 대한 체크섬 생성 가능
- 수신자는 모든 의도하지 않은 엔터티의 변경을 잡아내기 위해 그 체크섬으로 기본적인 검사 가능
- Content-MD5 헤더는 서버가 엔터티 본문에 MD5 알고리즘을 적용한 결과를 보내기 위해 사용
  - MD5 알고리즘: 128비트 암호화 해시 함수, 주로 프로그램이나 파일이 원본 그대로인지를 확인하는 무결성 검사에 사용
- 메시지 무결성 검사에 더해, MD5는 문서의 위치를 빠르게 알아내고 콘텐츠의 중복 저장을 방지 가능
- 이런 활용 가치에도 불구하고, Content-MD5 헤더는 자주 전송되지 않음

## 15.4 미디어 타입과 차셋(Charset)

- Content-Type 헤더 필드는 엔터티 본문의 MIME 타입을 기술

- Content-Type의 값은 인터넷 할당 번호 관리 기관(Internet Assigned Numbers Authority, IANA)에 등록된 표준화된 MIME 타입
- Content-Type 헤더가 원본 엔터티 본문의 미디어 타입을 명시한다는 것은 중요함

### 15.4.1 텍스트 매체를 위한 문자 인코딩

- Content-Type 헤더는 내용 유형을 더 자세히 지정하기 위한 선택적인 매개변수도 지원

- 엔터티의 비트 집합을 텍스트 파일의 글자들로 변환하기 위한 'charset' 매개변수가 대표적

  `Content-Type: text/html; charset=iso-8859-4`

### 15.4.2 멀티파트 미디어 타입

- MIME '멀티파트' 이메일 메시지는 서로 붙어있는 여러 개의 메시지를 포함하며, 하나의 복합 메시지로 보내짐
- 각 구성요소는 자족적으로 자신에 대해 서술하는 헤더 포함
- HTTP는 멀티파트 본문도 지원하지만, 일반적으로는 폼을 채워서 제출할 때와 문서의 일부분을 실어 나르는 범위 응답을 할때 사용

### 15.4.3 멀티파트 폼 제출

- HTTP 폼을 채워서 제출하면, 가변 길이 텍스트 필드와 업로드 될 객체는 각각이 멀티파트 본문을 구성하는 하나의 파트가 되어 보내짐
- HTTP는 그러한 요청을 `Content-Type: multipart/form-data`나 `Content-Type: multipart/mixed` 헤더에 본문을 함께 보냄

### 15.4.4 멀티파트 범위 응답

- 범위 응답에 대한 HTTP 응답 또한 멀티파트가 될 수도 있음
- `Content-Type: multipart/byteranges` 헤더 및 각각 다른 범위를 담고 있는 멀티파트 본문이 함께 옴

## 15.5 콘텐츠 인코딩

- HTTP 애플리케이션은 때때로 콘텐츠를 보내기 전에 인코딩을 하려고 함
- 콘텐츠 인코딩은 발송하는 쪽에서 콘텐츠에 적용, 인코디잉 끝난 데이터는 엔터티 본문에 담아 수신자에게 전송

### 15.5.1 콘텐츠 인코딩 과정

1. 웹 서버가 원본 Content-Type과 Content-Length 헤더를 수반한 원본 응답 메시지 생성

2. 콘텐츠 인코딩 서버가 인코딩 메시지 생성, 인코딩된 메시지는 Content-Type은 같지만 Content-Length는 다름

   콘텐츠 인코딩 서버는 Content-Encoding 헤더를 인코딩된 메시지에 추가하여, 수신측에 디코딩 가능케 함

3. 수신 측은 인코딩된 메시지를 받아서 디코딩하고 원본 획득

### 15.5.2 콘텐츠 인코딩 유형

- HTTP는 몇 가지 표준 콘텐츠 인코딩 유형을 정의하고 확장 인코딩으로 인코딩을 추가하는 것을 허용
- 인코딩은 각 콘텐츠 인코딩 알고리즘에 고유한 토큰을 할당하는 IANA를 통해 표준화

| 콘텐츠 인코딩 값 | 설명                                                         |
| ---------------- | ------------------------------------------------------------ |
| gzip             | 엔터티에 GNU zip 인코딩이 적용되었음을 의미                  |
| compress         | 엔터티에 대해 유닉스 압축 프로그램인 'compress'가 실행되었음을 의미 |
| deflate          | 엔터티가 zlib 포멧으로 압축되었음을 의미                     |
| identity         | 엔터티에 어떤 인코딩도 수행되지 않았음을 의미. Content-Encoding 헤더가 없다면 이 값으로 간주 |

- gzip이 일반적으로 가장 효율적이고 가장 널리 쓰이는 압축 알고리즘

### 15.5.3 Accept-Encoding 헤더

- 클라이언트가 해독 불가능한 방법으로 서버가 콘텐츠를 인코딩하는 것을 지양
- 클라이언트가 지원하는 인코딩 목록을 Accept-Encoding 요청 헤더를 전달
- Accept-Encoding 헤더를 포함하지 않는다면, 서버는 클라이언트가 어떤 인코딩이든 받을 수 있는 것으로 간주

- 클라이언트는 각 인코딩에 Q(quality) 값을 매개 변수로 선호도를 나타낼 수 있음 (0.0 ~ 1.0)

## 15.6 전송 인코딩과 청크 인코딩

### 15.6.1 안전한 전송

- 표준화되고 더 너그러운 전송 기반을 갖춘 HTTP는 '안전한 전송'에 초점
- HTTP에서 전송된 메시지의 본문이 문제를 일으키는 경우
  - 알 수 없는 크기
  - 보안

### 15.6.2 Transfer-Encoding 헤더

- 전송 인코딩을 제어하고 서술하기 위해 정의된 두개의 헤더

  - Transfer-Encoding

    - 안전한 전송을 위해 어떤 인코딩이 메시지에 적용되었는지 수신자에게 알려줌

  - TE (HTTP/1.1)

    - 어떤 확장된 전송 인코딩을 사용 가능핮ㄴ지 서버에게 알려주기 위해 요청 헤더에 사용

### 15.6.3 청크 인코딩

- 청크 인코딩은 메시지를 일정 크기의 청크 여럿으로 쪼갬
- 서버는 각 청크를 순차적으로 전송
- 청크 인코딩을 이용하면 메시지를 보내기 전에 전체 크기를 알 필요가 없어짐

#### 15.6.3.1 청크와 지속 커넥션

- 클라이언트와 서버 사이의 커넥션이 지속적이지 않다면, 클라이언트는 자신이 읽고 있는 본문의 크기를 알 필요 없음
- 지속 커넥션에서는, 본문을 쓰기 전에 반드시 Content-Length 헤더에 본문의 길이를 담아서 보내야 함
- 클라이언트는 서버가 청크 인코딩을 받아들여줄지 모르기 때문에, 청크 요청이 411 에러로 거절하는 것에 대비해야 함

#### 15.6.3.2 청크 인코딩된 메시지의 트레일러

- 다음의 조건중 하나 이상을 만족하면 청크 메시지에 트레일러 추가 가능
  - 클라이언트의 TE 헤더가 트레일러를 받아들일 수 있음을 나타내고 있는 경우
  - 트레일러가 응답을 만든 서버에 의해 추가되었으며, 그 트레일러의 콘텐츠는 클라이언트가 이해하고 사용할 필요가 없는 선택적인 케타데이터이므로 클라이언트가 무시하고 버려도 되는 경우
- 트레일러에는 본문의 콘텐츠가 먼저 생성되어야 한다거나 하는 등의 이유로 메시지 시작 시점에서는 알 수 없는 헤더 추가 가능
- Transfer-Encoding, Trailer, Content-Length를 제외한 어떤 HTTP 헤더도 트레일러로 전송 가능

### 15.6.4 콘텐츠와 전송 인코딩의 조합

- 콘텐츠 인코딩과 전송 인코딩은 동시 사용 가능

### 15.6.5 전송 인코딩 규칙

- 전송 인코딩의 잡합은 반드시 'chunked'를 포함해야 함, 유일한 예외는 메시지가 커넥션의 종료로 끝나는 경우 뿐
- 청크 전송 인코딩이 사용되었다면, 메시지 본문에 적용된 마지막 전송 인코딩이 존재해야 함
- 청크 전송 인코딩은 반드시 메시지 본문에 한 번 이상 적용되어야 함
- 전송 인코딩은 HTTP/1.1 에서 소개된 비교적 새로운 기능
- 어떠한 HTTP/1.1 애플리케이션이라도 최소한 청크 인코딩만은 반드시 지원해야 함


​    