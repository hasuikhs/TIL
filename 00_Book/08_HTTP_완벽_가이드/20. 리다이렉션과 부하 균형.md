# 20. 리다이렉션과 부하 균형

- 리다이렉션 보통 메시지가 프락시, 캐시, 서버 팜의 특정 웹 서버 중 어디에서 끝나는지 판별하기 위해 사용
- 리다이렉션은 클라이언트의 메시지를 명시적으로 요청하지 않은 곳으로 전송 가능

## 20.1 왜 리다이렉트인가?

- 리다이렉션은 다음의 HTTP 애플리케이션의 요구 세가지의 이유로 현대의 웹에서는 불가피함
  - 신뢰 가능한 HTTP 트렌젹션의 수행
  - 지연 최소화
  - 네트워크 대역폭 절약
- 이러한 이유로 웹 콘텐츠는 흔히 여러 장소에 배포
  - 한 곳에서 실패한 경우 다른 곳을 이용 가능하므로 신뢰성 개선 가능
  - 클라이언트가 보다 가까운 리소스에 접근 가능하여 콘텐츠를 더 빨리 받게 되므로 응답시간 감소
  - 서버가 분산되므로 네트워크 혼잡 감소
- 리다이렉션이란 최적의 분산된 콘텐츠를 찾는 것을 도와주는 기법의 집합이라 생각 가능
- 리다이렉션 구현에는 부하 균형의 과제가 포함
  - 들어오는 메시지의 부하를 서버들의 집합에게 분산 가능
  - 반대의 경우도 어떤 방식의 부하 균형이든 리다이렉션을 포함

## 20.2 리다이렉트 할 곳

- 서버, 프락시, 캐시, 게이트웨이가 모두 공통적으로 서버의 특성을 갖고있기에 많은 리다이렉션은 모두에서 동작
- 그러나 특정 종류의 종단만을 위해 특별히 설계되어 일반적인 적용이 불가능한 리다이렉션 존재
- 웹 서버는 IP별로 요청을 다룸
  - 복제된 서버들로 요청을 분산한다는 것은 같은 URL에 대해 여러 곳에서 온 요청들을 각각 최적의 웹 서버로 전송한단 의미
- 프락시는 프로토콜별로 요청을 다룸
  - 이상적으로, 프락시 이웃의 모든 HTTP 트래픽은 프락시를 거쳐야 함
  - 캐시는 자주 찾는 문서를 저장하여 클라이언트에게 제공하기 때문에 리소스가 많이 드는 통신 회피 가능
  - 프락시로의 리다이렉트는 주 진입로의 트래픽을 근처에 있는 지름길로 빨아들이는 것과 같음

## 20.3 리다이렉션 프로토콜의 개요

- 리다이렉션의 목표는 HTTP 메시지를 가용한 웹 서버로 가급적 빨리 보내는 것
- 브라우저 설정, DNS, TCP/IP 라우팅, 그리고 HTTP는 모두 메시지를 리다이렉트하는 메커니즘을 제공
- DNS 리다이렉션을 비롯한 대부분의 기법들이 트래픽을 보내려는 곳이 어떤 서버냐에 상관없이 사용 가능한것에 반해 브라우저 설정과 같은 방법은 프락시로 향하는 리다이렉트 트래픽에 대해서만 사용 가능하다는 점에 주의

## 20.4 일반적인 리다이렉션 방법

### 20.4.1 HTTP 리다이렉션

- 몇몇 웹 사이트는 HTTP 리다이렉션을 이용해 간단하게 부하를 분산함
- 요청을 처리하는 서버는 가용한 것들 중 부하가 가장 적은 콘텐츠 서버를 찾아서 브라우저의 요청을 그 서버로 리다이렉트
- 웹 서버들이 광범위하게 분산되어 있다면 '최선의' 가용한 서버를 결정하는 것은 더욱 어려워짐
- 다른 리다이렉션에 비해 HTTP 리다이렉션이 갖는 장점 중 하나는 리다이렉트를 하는 서버가 클라이언트의 IP 주소를 안다는 것
- HTTP 리다이렉션은 서버로 향하는 요청의 방향을 변경 가능하지만, 몇 가지 단점이 있음
  - 어떤 서버로 리다이렉트할지 결정하려면 많은 처리를 해야하는데, 때로는 페이지 자체를 제공할 때와 같은 양의 처리가 필요
  - 페이지에 접근할 때마다 두 번의 왕복이 필요하기에 사용자가 더 오래 기다리게 함
  - 만양 리다이렉트 서버가 고장 나면, 사이트도 고장남
- 이러한 약점 때문에, HTTP 리다이렉션은 보통 몇몇 다른 리다이렉션 기법과 함께 조합하여 사용

### 20.4.2 DNS 리다이렉션

- DNS는 하나의 도메인에 여러 아이피 주소가 결부되는 것을 허용하며, DNS 분석자는 여러 IP 주소를 반환하도록 설정 가능
- **DNS 라운드 로빈**
  - DNS 라운드 로빈은 가장 ㅅ흔한 동시에 가장 단순한 리다이렉션 기법
  - 웹 서버 팜 전체에 대한 부하의 균형을 유지하기 위해 DNS 호스트 명 분석 기능을 사용
  - 순수한 부하 균형 전략이며, 서버에 대한 클라이언트의 상대적 위치나 서버의 현재 스트레스를 고려하지 않음
- **다중 주소와 라운드 로빈 주소 순환**
  - 대부분의 DNS 클라이언트는 그냥 다중 주소 집합의 첫 번째 주소 사용
  - 부하 균형을 위해, 대부분의 DNS 서버는 룩업이 끝났을 때마다 주소 순환, 이른 DNS 라운드 로빈이라 함
- **부하 균형을 위한 DNS 라운드 로빈**
  - 대부분의 DNS 클라이언트는 그냥 첫 번째 주소를 사용하기에, DNS 순환은 서버들 간의 부하 균형을 유지
  - 만약 DNS가 주소를 순환시키지 않으면, 대부분의 클라이언트가 목록의 첫 번째 서버를 선택하여 부하의 균형이 깨짐
- **DNS 캐싱의 효과**
  - 서버에 대한 각 DNS 룩업은 서버 주소를 가져오면서 부하를 순환시킴
  - 그러나, 이 부하 균형은 완벽하지 않음
    - DNS 룩업의 결과는 애플리케이션, 운영체제, 몇몇 자식 DNS 서버에 의해 기억되어 재사용 가능하기 때문
    - 호스트 하나에 대해 한 번의 DNS 룩업을 수행한 뒤, 그 주소를 몇 번이고 재사용
- **다른 DNS 기반 리다이렉션 알고리즘**
  - 몇몇 향상된 DNS 서버는 주소의 순서를 결정하기 위해 다른 기법들을 사용
    - 부하 균형 알고리즘
    - 근접 라우팅 알고리즘
    - 결함 마스킹 알고리즘

### 20.4.3 임의 캐스팅 어드레싱

- 클라이언트에서 가장 가까운 서버로 보내주기 위해 백본 라우터의 '최단거리' 라우팅 능력에 의지
- 웹 서버는 라우터 통신 프로토콜을 이용해 자신과 인접한 백본 라우터와 대화
- 분산 임의 캐스트의 동작을 위해, 서버는 반드시 '라우터 언어로 말해야 하고' 라우터는 일어날 수 있는 주소 충돌을 반드시 다룰 수 있어야 함
- 분산 임의 캐스트는 최근에 만들어진 기술이며 그들 자신의 백본 네트워크를 제어하는 콘텐츠 제공자들을 위한 솔루션이 될 수 있음

### 20.4.4 IP MAC 포워딩

### 20.4.5 IP 주소 포워딩

- MAC 포워딩보다 좋은 점 하나는 목적지 서버가 한 홉 거리에 있을 필요가 없음
- 그저 스위치에서 업스트림의 위치를 판별 가능하면 일반적인 레이어-3 종단간(end-to-end) 라우팅이 패킷을 올바른 위치로 전송
- 이러한 전달은 네트워크 주소 변환(Network Address Translation, NAT)이라고 불림
- 그러나 여기에는 라우팅 대칭성이라는 문제 존재
  - 클라이언트로부터 들어노는 TCP 커넥션을 받아주는 스위치는 그 커넥션을 관리
  - 스위치는 반드시 그 커넥션을 통해 클라이언트에게 응답을 돌려주어야 함
  - 그러므로 목적지 서버나 프락시로부터의 모든 응답은 반드시 그 스위치에게 돌아가야 함

### 20.4.6 네트워크 구성요소 제어 프로토콜(Network Element Control Protocol, NECP)

- IP 패킷을 전달하는 라우터나 스위치 같은 네트워크 구성요소들(NE)이 웹 서버나 프락시 캐시와 같이 애플리케이션 계층 요청을 처리하는 서버 구성 요소들(SE)과 대화 가능하게 해줌
- NECP는 부하 균형을 명시적으로는 지원하지 않음
  - 다만 SE는 NE에게 부하 균형 정보를 제공 가능한 방법을 제공하여, SE가 적합하다고 판단한 대로 NE가 부하 균형 유지 가능케 함
  - WCCP와 마찬가지로 NECP는 MAC 포워딩, GRE 캡슐화, NAT와 같은 패킷을 전달하는 여러 방법 제공
- NECP는 예외에 대한 개념을 지원하여, SE는 특정 출발지 IP 주소가 서비스 불가능하다고 판단 가능하며, 그러한 경우 그 주소들을 NE로 보낼 수 있고, NE는 그 IP 주소로부터의 요청을 원 서버로 전달 가능

## 20.5 프락시 리다이렉션 방법

- 프락시는 결과적으로 클라이언트의 요청을 다른 프락시로 리다이렉트 가능

### 20.5.1 명시적 브라우저 설정

- 대부분의 브라우저에는 프락시 서버에 접촉하기 위해 프락시 이름, IP 주소, 포트번호 설정 가능한 풀다운 메뉴 존재
- 사용자가 이를 설정하면 브라우저는 모든 요청에 대해 프락시와 접촉
- 몇몇 서비스 제공자들은 사용자들의 직접 설정하는 대신, 미리 설정이 다 되어 있는 브라우저를 제공
- 명시적 브라우저 설정의 단점
  - 프락시들을 사용하도록 설정된 브라우저들은 프락시가 응답하지 않더라도 원 서버와 접촉하지 않음
  - 네트워크 아키텍처를 변경했을 때 그 변경사항을 모든 최종 사용자에게 전파하는 것이 어려움

### 20.5.2 프락시 자동 설정

- 특정 프락시에 접촉하기 위한 브라우저의 명시적인 설정은  네트워크 아키텍처의 변화를 제한
- 올바른 프락시 서버에 접촉하기 위해 브라우저가 동적으로 자신을 설정 가능케 하는 자동 설정 방법으로 해결
- 이 방법은 실제로 존재하며 프락시 자동설정(Proxy Auto-configuration, PAC) 프로토콜이라 불림
- PAC의 기본 아이디어는 브라우저들이 URL 별로 접촉해야 할 프락시를 지정한 PAC 파일이라 불리는 특별한 파일을 찾도록 하는 것
- 브라우저는 반드시 PAC 파일을 얻기 위해 지정된 서버에 접촉하도록 설정되면, 브라우저는 재시작할 때마다 PAC 파일을 가져옴

### 20.5.4 웹 프락시 자동발견 프로토콜(Web Proxy Autodiscovery Protocol)

- 웹 프락시 자동발견 프로토콜(WPAD)은 최종 사용자가 수동으로 프락시 설정을 할 필요도, 투명한 트래픽 인터셉트에 의존할 필요도 없이 웹브라우저가 근처의 프락시를 찾아내어 사용 가능하게 해주는 방법을 제공하는 것이 목적
- **PAC 파일 자동 발견**
  - WPAD는 HTTP 클라이언트가 PAC 파일의 위치를 알아내고 파일을 이용해서 적절한 프락시 서버의 이름을 알아낼 수 있게  해줌
  - WPAD는 PAC 파일에 의해 제공되는 추가적인 기능을 활용 불가능한 이유로, 직접적으로 프락시 서버의 이름을 알아내지는 않음
- **WPAD 알고리즘**
  - WPAD는 적절한 PAC 파일 CURL을 결정하기 위해 여러가지 리소스 발견 기법들을 사용
    - DHCP(Dynamic Host Configuration Protocol, 동적 호스트 설정 프로토콜)
    - SLP(Service Location Protocol, 서비스 위치 프로토콜)
    - DNS에게 잘 알려진 호스트 명
    - DNS의 SRV 레코드
    - TXT 레코드의 DNS 서비스 URL들

## 20.6 캐시 리다이렉션 방법

- 신뢰성 높고, 고성능에, 콘텐츠 지각 디스패칭(content-aware-dispatching, 콘텐츠의 특정 일부를 갖고 있을 것으로 추정되는 곳으로 요청을 보냄)까지 가능하게 하려고 하기 때문에, 앞의 프로토콜보다 복잡함

### 20.6.1 WCCP 리다이렉션

- WCCP는 라우터들과 캐시들 사이의 대화를 관리하여 라우터가 캐시를 검사하고, 특정 종류의 트래픽을 특정 캐시로 전송 가능케 해줌

- 자세한 내용은 책을 참고...

## 20.7 인터넷 캐시 프로토콜

- 캐시들이 형제 캐시에서 일어난 캐시 적중을 찾아볼 수 있도록 해줌
- 만약 캐시가 HTTP 메시지에서 요청한 콘텐츠를 갖고 있지 않다면, 캐시는 근처의 형제 캐시 중 콘텐츠를 갖고 있는 것이 있는지 찾음
- 인터넷 캐시 프로토콜(ICP)는 단순하고 가벼움
  - ICP 메시지는 파싱하기 쉽도록 네트워크 바이트 순서에 따라 32비트 크기로 맞추어진 구조체
  - 이 메시지들은 효율을 위해 UDP 다이어그램을 전송
  - UDP는 실뢰 불가능한 인터넷 프로토콜이여서, 데이터그램의 손실 감지 가능하게 타임아웃이 설정되어야 함
- ICP 메시지의 각 부분들
  - OP 코드
    -  ICP 메시지의 의미를 서술하는 8비트 값
  - 버전
  - 메시지 길이
    - ICP 메시지의 총 길이를 바이트 단위로 나타낸 것
    - 저장 공간이 16비트밖에 안되어, 16,383 비트를 넘을 수 없음
  - 요청 번호
    - ICP를 지원하는 캐시는 동시에 여러 요청과 응답을 추적하기 위해 요청 번호를 사용
  - 옵션
    - ICP의 동작을 변경하는 플래그를 담고 있는 비트 벡터
  - 옵션 데이터
  - 발송자 호스트 주소
  - 페이로드

## 20.8 캐시 배열 라우팅 프로토콜(CARP)

- 캐시 배열 라우팅 프로토콜은 여러대의 프락시 서버를 클라이언트의 시점에서는 마치 하나의 캐시처럼 보이게 해주는 방법
- CARP와 ICP 둘 다 관리자가 여러 대의 프락시 서버를 사용하여 성능 개선을 도모
- ICP 프로토콜로 서로 연결된 프락시 서버들 각각은 콘텐츠의 쓸데 없는 복제본(중복)이 허용되는 독립적인 캐시
- CARP를 이용해서 동작하는 서버들의 무리는, 각 구성요소 서버가 전체 캐시된 문서의 일부만 가지고 하나의 큰 서버처럼 동작
- 그러나 CARP은 프락시 서버 중 하나가 사용 불가능하면, 이 사실을 반영하기 위해 해시 함수가 수정되어야 하고,  프락시 서버 전체에 퍼져 있는 콘텐츠들도 다시 배치하지 않을 수 없다는 단점 존재
- 반면 ICP 프락시 서버들에는 콘텐츠가 중복되어 존재하므로 다시 배치할 필요가 없음



