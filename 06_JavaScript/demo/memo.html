<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Memo</title>
    <style>
      .section {
        display: flex;
        padding: 10px;
        justify-content: space-between;
      }
      .title {
        display: flex;
        justify-content: center;
        align-items: center;
        font-weight: 600;
        min-width: 200px;
        height: inherit;
        border-right: 1px solid black;
        margin-right: 10px;
      }
      p {
        word-break: break-word;
      }
      .memo {
        font-style: italic;
        border-radius: 3px;
        background-color: #f8ca8f;
      }
      .memo:hover {
        text-decoration: underline;
        cursor: pointer;
      }
      .modal {
        position: absolute;
        top: 50%;
        left: 50%;
        margin-left: -140px;
        display: flex;
        margin-top: -50px;
        visibility: hidden;
        opacity: 0;
        justify-content: space-between;
        padding: 10px;
        border-radius: 5px;
        border: 1px solid black;
        width: 300px;
        height: 120px;
        background-color: white;
        box-shadow: 5px 5px 5px #d6d6d6;
        transition: ease 0.5s;
      }
      .memo-input {
        padding: 5px;
        width: 200px;
        resize: none;
      }
      .memo-ing {
        background-color: #f9f9c8;
      }
      .memo-update {
        background-color: #9cdef8;
      }
      .text-notice {
        position: absolute;
        top: 107px;
        left: 158px;
        pointer-events: none;
        width: 60px;
        text-align: right;
        opacity: 0.6;
      }
      #memo-popup {
        display: none;
        width: 45px;
        /* height: 15px; */
        background-color: white;
        border: 1px solid #eaeaea;
        border-radius: 5px;
      }
      mark {
        background-color: aqua !important;
        border-radius: 5px;
      }
      mark > .memo {
        background-color: inherit;
      }
    </style>
  </head>
  <body>
    <h1>MEMO TEST</h1>

    <div id="container">
      <div key="FIELD_OF_THE_INVENTION" id="FIELD_OF_THE_INVENTION">
        <p>
          <strong>【Paragraph 1】</strong>
        </p>
        <div key="P-0003" id="P-0003">
          <p>
            <strong>【0001】</strong>
          </p>
          Lorem ipsum dolor <span class="memo">sit</span> amet consectetur
          adipisicing elit. Ab asperiores, ullam architecto omnis voluptatum
          dolor quia, est, saepe earum fugiat consectetur dicta autem corporis
          nemo delectus totam. Doloremque voluptate molestiae laboriosam
          possimus sed? Excepturi veritatis, blanditiis ea ratione obcaecati
          magnam earum magni temporibus officiis error porro incidunt ipsum quae
          repudiandae expedita fugiat itaque delectus. Ad quisquam provident
          odio. Quo iste, in explicabo, nulla tempore animi quasi ducimus
          numquam sint et perferendis ratione accusamus mollitia debitis earum
          voluptates. Cumque officiis expedita consequuntur libero labore,
          assumenda, explicabo dicta, maiores hic earum illum modi voluptate
          consequatur rerum ducimus voluptatum doloribus accusantium animi
          saepe!
          <mark
            data-markjs="true"
            id="-1204461845-1-1"
            name="-1204461845-1"
            class="mark--1204461845 palette-fac76c"
            >organic</mark
          >
          Lorem ipsum dolor sit amet consectetur adipisicing elit. Deserunt,
          sapiente.
        </div>
      </div>

      <div key="FIELD_OF_THE_INVENTION" id="FIELD_OF_THE_INVENTION_2">
        <p>
          <strong>【Paragraph 2】</strong>
        </p>
        <div key="P-0004" id="P-0004">
          <p>
            <strong>【0002】</strong>
          </p>
          Lorem ipsum dolor sit amet consectetur adipisicing elit. Tenetur est
          nemo officiis, qui nam amet enim consequuntur itaque voluptate
          facilis, blanditiis numquam. Magni, veritatis aperiam a modi labore
          esse nisi libero cupiditate possimus, tenetur hic corrupti nemo
          voluptas distinctio deleniti cum quos dolores sapiente temporibus,
          expedita molestias deserunt consequatur maiores! Excepturi inventore
          quia illum ipsam corrupti sint suscipit id molestias accusamus rem
          voluptatum, libero illo dolor fuga exercitationem nam, minima minus
          assumenda dolores. Aliquam corporis odio illo id ex molestias a
          tempore explicabo ad, libero sequi fugit ipsa magnam incidunt
          veritatis nesciunt atque at non eum iusto? Laudantium, molestias eius!
          <mark
            data-markjs="true"
            id="-1204461845-1-1"
            name="-1204461845-1"
            class="mark--1204461845 palette-fac76c"
            >organic</mark
          >
          Lorem ipsum dolor sit amet consectetur adipisicing elit. Magnam
          distinctio modi suscipit quibusdam repellendus, culpa ab dicta ut
          numquam explicabo?
        </div>
      </div>
    </div>

    <div id="memo-modal" class="modal">
      <textarea
        class="memo-input"
        placeholder="메모를 입력해주세요."
        maxlength="100"
      ></textarea>
      <div class="text-notice">0/100</div>
      <button class="save-btn" type="button">저장</button>
      <button class="cancel-btn" type="button">취소</button>
    </div>

    <div id="memo-popup">
      <button type="button">memo</button>
    </div>

    <script>
      /*
       * 현재 제한 사항
       * 1. 메모가 중복 될 수 없음
       * 2. 메모가 현재 문단을 벗어 날 수 없음
       * 3. 드래그한 대상은 2글자 이상일때만 메모 제공
       */
      window.onload = () => {
        const memo = new Memo({ documentId: "test", containerId: "container" });
      };

      function Memo({ documentId, containerId }) {
        if (!new.target) {
          throw new Error("Create object using new operator.");
        }

        const COMMON_REGEX = /\s{2,}/g;

        this.documentId = documentId || "";

        this.container = document.getElementById(containerId);

        this.storage = JSON.parse(sessionStorage.getItem("data")) || [];

        this.target = null;
        this.parentTarget = null;

        this.selection = null;
        this.range = null;
        this.selectedText = null;
        this.originHtml = null;

        this.modal = document.getElementById("memo-modal");
        this.modalTextarea = this.modal.querySelector("textarea.memo-input");
        this.modalSaveBtn = this.modal.querySelector("button.save-btn");
        this.modalCancelBtn = this.modal.querySelector("button.cancel-btn");
        this.modalNotice = this.modal.querySelector("div.text-notice");

        this.mousePopup = document.getElementById("memo-popup");
        this.isMousePopupOver = false;

        this.groupedData = (data) => {
          const result = {};

          for (let i = 0, len = data.length; i < len; i++) {
            const item = data[i];
            const { parentId } = item;

            if (!result[parentId]) {
              result[parentId] = [];
            }

            result[parentId].push(item);
          }

          return result;
        };

        this.highlightStorageMemo = (element, start, end) => {
          if (end < start) throw new Error("Incorrect data");

          const treeWalker = document.createTreeWalker(
            element,
            NodeFilter.SHOW_TEXT,
            null,
            false
          );
          let currLength = 0;
          let desiredLength = end - start;

          let currentNode;
          while ((currentNode = treeWalker.nextNode())) {
            let nodeText = currentNode.nodeValue.replace(COMMON_REGEX, "");
            const nodeTextLength = nodeText.length;

            if (!nodeText) continue;

            if (desiredLength) {
              if (start > nodeText.length) {
                start -= nodeText.length;
                end -= nodeText.length;
              } else {
                let parentNode = currentNode.parentNode;

                const beforeText = nodeText.substring(0, start);
                const targetText = nodeText.substring(start, end);
                const afterText = nodeText.substring(end);

                const beforeTextNode = document.createTextNode(beforeText);
                const afterTextNode = document.createTextNode(afterText);

                const targetTextNode = document.createElement("span");
                targetTextNode.className = "memo";
                targetTextNode.textContent = targetText;

                parentNode.replaceChild(afterTextNode, currentNode);
                parentNode.insertBefore(targetTextNode, afterTextNode);
                parentNode.insertBefore(beforeTextNode, targetTextNode);

                end = afterText.length;

                this.highlightStorageMemo(element, 0, end);

                break;
              }
            } else {
              break;
            }
          }
        };

        this.loadStorageAndHighlight = () => {
          if (this.storage && this.storage.length) {
            const groupData = this.groupedData(
              this.storage.sort((a, b) => {
                if (a.parentId < b.parentId) return -1;
                if (a.parentId > b.parentId) return 1;
                if (a.start > b.start) return -1;
                if (a.start < b.start) return 1;
                return 0;
              })
            );

            for (const groupId in groupData) {
              if (groupData[groupId]) {
                const items = groupData[groupId];
                const element = document.getElementById(groupId);

                for (let i = 0, itemLen = items.length; i < itemLen; i++) {
                  const item = items[i];
                  const { start, end, targetText } = item;

                  console.log(start, end, targetText);
                  this.highlightStorageMemo(element, start, end);
                }
              }
            }
          }
        };

        this.verifyMemo = (selection, range) => {
          let possible = true;
          let message = "";

          if (document.querySelector(".memo-ing")) {
            possible = false;
            message = "이미 메모 작성 중";
          }

          if (this.target.classList.contains("memo")) {
            possible = false;
            message = "이미 메모가 존재";
          }

          const startNode =
            selection.anchorNode.parentNode.closest("li") ||
            selection.anchorNode.parentNode.closest("p") ||
            selection.anchorNode.parentNode.closest("div");
          const endNode =
            selection.focusNode.parentNode.closest("li") ||
            selection.focusNode.parentNode.closest("p") ||
            selection.focusNode.parentNode.closest("div");

          if (startNode !== endNode) {
            possible = false;
            message = "메모는 한 문단 안에서만 가능";
          }

          if (possible && range) {
            const textNodes = this.getTextNodesWithinRange(range);

            for (let i = 0, len = textNodes.length; i < len; i++) {
              const node = textNodes[i];

              if (node.parentNode.classList.contains("memo")) {
                possible = false;
                message = "기존 메모와 겹쳐서는 안 됨";
                break;
              }
            }
          }

          return { possible, message };
        };

        this.getTextNodesWithinRange = (range) => {
          const textNodes = [];
          const treeWalker = document.createTreeWalker(
            range.commonAncestorContainer,
            NodeFilter.SHOW_TEXT,
            null,
            false
          );

          let currentNode;
          while ((currentNode = treeWalker.nextNode())) {
            if (range.intersectsNode(currentNode)) {
              textNodes.push(currentNode);
            }
          }

          return textNodes;
        };

        this.highlightSelectedTextAndOpenModal = () => {
          this.selection = window.getSelection();
          this.selectedText = this.selection.toString();

          this.range = this.selection.getRangeAt(0);

          if (this.range) {
            const preSelectionRange = this.range.cloneRange();

            preSelectionRange.selectNodeContents(this.target);
            preSelectionRange.setEnd(
              this.range.startContainer,
              this.range.startOffset
            );

            const serializer = new XMLSerializer();
            this.originHtml = serializer.serializeToString(
              this.range.cloneContents()
            );

            this.range.start = preSelectionRange
              .toString()
              .replace(COMMON_REGEX, "").length;
            this.range.end = this.range.start + this.range.toString().length;

            // 선택된 텍스트 하이라이트
            const span = document.createElement("span");
            span.classList.add("memo");
            span.classList.add("memo-ing");
            span.appendChild(this.range.extractContents());
            this.range.insertNode(span);

            // 타겟 변경
            this.target = span;
            // 선택 해제
            this.selection.removeAllRanges();

            this.openModal();
          }
        };

        this.openModal = () => {
          this.modal.style.opacity = 1;
          this.modal.style.visibility = "visible";
          this.modal.style.pointerEvents = "auto";
          this.modalTextarea.focus();
        };

        this.hideModal = () => {
          this.modal.style.opacity = 0;
          this.modal.visibility = "hidden";
          this.modal.style.pointerEvents = "none";
          this.modalTextarea.value = "";
          this.modalNotice.innerText = "0/100";
        };

        this.setEvent = () => {
          this.setEventSaveButton();
          this.setEventCancelButton();
          this.setEventTextarea();
          this.setEventMousePopup();
        };

        this.setEventTextarea = () => {
          this.modalTextarea.addEventListener("keyup", () => {
            this.modalNotice.innerText = `${
              this.modalTextarea.value.length || 0
            }/100`;
          });
        };

        this.setEventSaveButton = () => {
          this.modalSaveBtn.addEventListener("click", () => {
            const memoText = this.modalTextarea.value;

            if (memoText.trim().length === 0) {
              return alert("메모 입력되지 않음");
            }

            console.log(this.range);
            if (this.target) {
              const data = {
                documentId: this.documentId,
                parentId: this.parentTarget.id,
                targetText: this.selectedText,
                start: this.range.start,
                end: this.range.end,
                memoText,
              };

              this.target.classList.remove("memo-ing");

              this.storage.push(data);

              sessionStorage.setItem("data", JSON.stringify(this.storage));
            }

            this.hideModal();
          });
        };

        this.setEventCancelButton = () => {
          this.modalCancelBtn.addEventListener("click", () => {
            const isUpdate = this.target.classList.contains(".memo-update");

            if (isUpdate) {
              this.target.classList.remove(".memo-update");
            } else if (this.target) {
              const targetHtml = this.target.outerHTML;

              // 취소시 현재 하이라이트 태그 지우기
              this.parentTarget.outerHTML = this.parentTarget.outerHTML.replace(
                targetHtml,
                this.originHtml
              );
            }

            this.hideModal();
          });
        };

        this.setEventMousePopup = () => {
          this.mousePopup.addEventListener("mouseover", (event) => {
            this.isMousePopupOver = true;
          });

          this.mousePopup.addEventListener("mouseout", (event) => {
            this.isMousePopupOver = false;
          });

          this.mousePopup.addEventListener("click", (event) => {
            this.mousePopup.style.display = "none";

            this.highlightSelectedTextAndOpenModal();
          });

          document.addEventListener("mousedown", (event) => {
            if (!this.isMousePopupOver) {
              this.mousePopup.style.display = "none";
            }
          });
        };

        this.init = () => {
          this.loadStorageAndHighlight();

          this.container.addEventListener("mouseup", (event) => {
            const selection = window.getSelection();
            const selectedText = selection.toString();

            const range = selection.getRangeAt(0);

            this.target = event.target;
            this.parentTarget = this.target.closest("div[id]");

            if (!selectedText.trim() || selectedText.trim().length < 2) {
              return;
            }

            const { possible, message } = this.verifyMemo(selection, range);

            if (possible) {
              this.mousePopup.style.display = "block";
              this.mousePopup.style.position = "absolute";
              this.mousePopup.style.left = `${
                event.x - (window.innerWidth > event.x + 40 ? 0 : 40)
              }px`;
              this.mousePopup.style.top = `${event.y}px`;
            }
          });

          this.setEvent();
        };

        this.init();
      }
    </script>
  </body>
</html>
