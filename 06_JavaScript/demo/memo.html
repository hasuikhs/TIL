<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Memo</title>
    <style>
      .section {
        display: flex;
        padding: 10px;
        justify-content: space-between;
      }
      .title {
        display: flex;
        justify-content: center;
        align-items: center;
        font-weight: 600;
        min-width: 200px;
        height: inherit;
        border-right: 1px solid black;
        margin-right: 10px;
      }
      p {
        word-break: break-word;
      }
      .memo {
        font-style: italic;
        border-radius: 3px;
        background-color: #f8ca8f !important;
      }
      .memo:hover {
        text-decoration: underline;
        cursor: pointer;
      }
      .modal {
        position: absolute;
        top: 50%;
        left: 50%;
        margin-left: -140px;
        display: flex;
        margin-top: -50px;
        visibility: hidden;
        opacity: 0;
        justify-content: space-between;
        padding: 10px;
        border-radius: 5px;
        border: 1px solid black;
        width: 300px;
        height: 120px;
        background-color: white;
        box-shadow: 5px 5px 5px #d6d6d6;
        transition: ease 0.5s;
      }
      .memo-input {
        padding: 5px;
        width: 200px;
        resize: none;
      }
      .memo-ing {
        background-color: #f9f9c8 !important;
      }
      .memo-update {
        background-color: #9cdef8;
      }
      .text-notice {
        position: absolute;
        top: 107px;
        left: 158px;
        pointer-events: none;
        width: 60px;
        text-align: right;
        opacity: 0.6;
      }
      #memo-popup {
        display: none;
        width: 45px;
        /* height: 15px; */
        background-color: white;
        border: 1px solid #eaeaea;
        border-radius: 5px;
      }
      mark {
        background-color: aqua !important;
        border-radius: 5px;
      }
      mark > .memo {
        background-color: inherit;
      }
    </style>
  </head>
  <body>
    <h1>MEMO TEST</h1>

    <div id="container">
      <div key="FIELD_OF_THE_INVENTION" id="FIELD_OF_THE_INVENTION">
        <p>
          <strong>【Paragraph 1】</strong>
        </p>
        <div key="P-0003" id="P-0003">
          <p>
            <strong>【0001】</strong>
          </p>
          Lorem ipsum dolor sit amet consectetur
          adipisicing elit. Ab asperiores, ullam architecto omnis voluptatum
          dolor quia, est, saepe earum fugiat consectetur dicta autem corporis
          nemo delectus totam. Doloremque voluptate molestiae laboriosam
          possimus sed? Excepturi veritatis, blanditiis ea ratione obcaecati
          magnam earum magni temporibus officiis error porro incidunt ipsum quae
          repudiandae expedita fugiat itaque <span class="memo">memo test</span> delectus. Ad quisquam provident
          odio. Quo iste, in explicabo, nulla tempore animi quasi ducimus
          numquam sint et perferendis ratione accusamus mollitia debitis earum
          voluptates. Cumque officiis expedita consequuntur libero labore,
          assumenda, explicabo dicta, maiores hic earum illum modi voluptate
          consequatur rerum ducimus voluptatum doloribus accusantium animi
          saepe!
          <mark
            data-markjs="true"
            id="-1204461845-1-1"
            name="-1204461845-1"
            class="mark--1204461845 palette-fac76c"
            >organic</mark
          >
          Lorem ipsum dolor sit amet consectetur adipisicing elit. Deserunt,
          sapiente.
        </div>
      </div>

      <div key="FIELD_OF_THE_INVENTION" id="FIELD_OF_THE_INVENTION_2">
        <p>
          <strong>【Paragraph 2】</strong>
        </p>
        <div key="P-0004" id="P-0004">
          <p>
            <strong>【0002】</strong>
          </p>
          Lorem ipsum dolor sit amet consectetur adipisicing elit. Tenetur est
          nemo officiis, qui nam amet enim consequuntur itaque voluptate
          facilis, blanditiis numquam. Magni, veritatis aperiam a modi labore
          esse nisi libero cupiditate possimus, tenetur hic corrupti nemo
          voluptas distinctio deleniti cum quos dolores sapiente temporibus,
          expedita molestias deserunt consequatur maiores! Excepturi inventore
          quia illum ipsam corrupti sint suscipit id molestias accusamus rem
          voluptatum, libero illo dolor fuga exercitationem nam, minima minus
          assumenda dolores. Aliquam corporis odio illo id ex molestias a
          tempore explicabo ad, libero sequi fugit ipsa magnam incidunt
          veritatis nesciunt atque at non eum iusto? Laudantium, molestias eius!
          <mark
            data-markjs="true"
            id="-1204461845-1-1"
            name="-1204461845-1"
            class="mark--1204461845 palette-fac76c"
            >organic</mark
          >
          Lorem ipsum dolor sit amet consectetur adipisicing elit. Magnam
          distinctio modi suscipit quibusdam repellendus, culpa ab dicta ut
          numquam explicabo?
        </div>
        <p>
          <strong>【Paragraph 3】</strong>
        </p>
        <div num="0003">
          <div>【0003】</div>
          Lorem ipsum dolor sit amet consectetur adipisicing elit. Ratione ipsam placeat sapiente consequatur repudiandae, numquam similique, ad vel tempore dolorem eaque explicabo id temporibus voluptatibus quis harum ea saepe perferendis nulla corrupti? Iste fuga excepturi voluptate recusandae molestias, dolores numquam.
        </div>
      </div>
    </div>

    <div id="memo-modal" class="modal">
      <textarea
        class="memo-input"
        placeholder="메모를 입력해주세요."
        maxlength="100"
      ></textarea>
      <div class="text-notice">0/100</div>
      <button class="save-btn" type="button">저장</button>
      <button class="cancel-btn" type="button">취소</button>
    </div>

    <div id="memo-popup">
      <button type="button">memo</button>
    </div>

    <script>
      /*
       * 현재 제한 사항
       * 1. 메모가 중복 될 수 없음
       * 2. 메모가 현재 문단을 벗어 날 수 없음
       * 3. 드래그한 대상은 2글자 이상일때만 메모 제공
       */
      window.onload = () => {
        const memo = new Memo({ documentId: 'test', containerId: 'container' });
      };

      function Memo({ documentId, containerId }) {
        if (!new.target) {
          throw new Error('Create object using new operator.');
        }

        const COMMON_REGEX = /\s{2,}/g;
        const MEMO_CLASSNAME        = 'memo';
        const MEMO_ING_CLASSNAME    = 'memo-ing';
        const MEMO_UPDATE_CLASSNAME = 'memo-update'

        this.isDragging = false;

        this.documentId = documentId || '';
        this.container  = document.getElementById(containerId);

        this.storage    = JSON.parse(sessionStorage.getItem('data')) || [];

        this.target       = null;
        this.parentTarget = null;

        this.selection    = null;
        this.range        = null;
        this.selectedText = null;
        this.originHtml   = null;

        this.modal          = document.getElementById('memo-modal');
        this.modalTextarea  = this.modal.querySelector('textarea.memo-input');
        this.modalSaveBtn   = this.modal.querySelector('button.save-btn');
        this.modalCancelBtn = this.modal.querySelector('button.cancel-btn');
        this.modalNotice    = this.modal.querySelector('div.text-notice');

        this.mousePopup   = document.getElementById('memo-popup');
        this.isPopupHover = false;

        this.tmpStart = 0;
        this.tmpEnd   = 0;

        this.groupedData = (data) => {
          const result = {};

          for (let i = 0, len = data.length; i < len; i++) {
            const item = data[i];
            const { parentSelector } = item;

            if (!result[parentSelector]) {
              result[parentSelector] = [];
            }

            result[parentSelector].push(item);
          }

          return result;
        };

        this.removeHighlightElement = () => {

        }

        this.addHighlightElement = (element, start, end, classNames = []) => {
          if (end < start) throw new Error('Incorrect data');
          console.log(start, end)

          const treeWalker = document.createTreeWalker(
            element,
            NodeFilter.SHOW_TEXT,
            null,
            false
          );
          let currLength = 0;

          let currentNode;
          let flag = false;
          while (currentNode = treeWalker.nextNode()) {
            console.log(currentNode)
            const nodeText       = currentNode.nodeValue;
            const nodeTextLength = nodeText.length;
            console.log(start, end)

            if (!nodeText) continue;

            // if (end - start > 0) {
            //   if (start > nodeText.length) {
            //     start -= nodeText.length;
            //     end   -= nodeText.length;

            //     console.log(start, end)
            //   } else {
            //     console.log('왜 안와요')
            //     const parentNode = currentNode.parentNode;

            //     const beforeText = !flag ? nodeText.substring(0, start) : nodeText.substring(0, 0);
            //     const targetText = nodeText.substring(start, end);
            //     const afterText  = nodeText.substring(end);

            //     start -= targetText.length;
            //     end   -= targetText.length;

            //     console.log(beforeText, beforeText.length);
            //     console.log(targetText, targetText.length);
            //     console.log(afterText, afterText.length);

            //     flag = true;
            //   }

            //   // const beforeTextNode =

            //   // if (start > nodeText.length) {
            //   //   start -= nodeText.length;
            //   //   end   -= nodeText.length;
            //   // } else {
            //   //   let parentNode = currentNode.parentNode;
            //   //   console.log(parentNode)

            //   //   const beforeText = nodeText.substring(0, start);
            //   //   const targetText = nodeText.substring(start, end);
            //   //   const afterText  = nodeText.substring(end);

            //   //   console.log(beforeText)
            //   //   console.log(targetText.length)
            //   //   console.log(afterText.length)

            //   //   const beforeTextNode = document.createTextNode(beforeText);
            //   //   const afterTextNode  = document.createTextNode(afterText);

            //   //   const targetTextNode = document.createElement('span');
            //   //   targetTextNode.textContent = targetText;

            //   //   classNames.forEach(className => targetTextNode.classList.add(className));
                

            //   //   parentNode.replaceChild(afterTextNode, currentNode);
            //   //   parentNode.insertBefore(targetTextNode, afterTextNode);
            //   //   parentNode.insertBefore(beforeTextNode, targetTextNode);

            //   //   // if (parentNode === this.parentTarget) {
            //   //   //   this.addHighlightElement(element, start + targetText.length, end, classNames);
            //   //   // } else {
            //   //   //   this.addHighlightElement(element, 0, end, classNames);
            //   //   // }

            //   //   // end -= targetText.length;

            //   //   // console.log(parentNode === this.parentTarget)

            //   //   // this.addHighlightElement(element, 0, end, classNames);

            //   //   break;
            //   // }
            // } else {
            //   break;
            // }
          }
        };

        this.loadStorageAndHighlight = () => {
          if (this.storage && this.storage.length) {
            const groupData = this.groupedData(
              this.storage.sort((a, b) => {
                if (a.parentSelector < b.parentSelector) return -1;
                if (a.parentSelector > b.parentSelector) return 1;
                if (a.start > b.start) return -1;
                if (a.start < b.start) return 1;
                return 0;
              })
            );

            for (const groupSelector in groupData) {
              if (groupData[groupSelector]) {
                const items   = groupData[groupSelector];
                const element = document.querySelector(groupSelector);

                for (let i = 0, itemLen = items.length; i < itemLen; i++) {
                  const item = items[i];
                  const { start, end, targetText } = item;

                  this.addHighlightElement(element, start, end, [ MEMO_CLASSNAME ]);
                }
              }
            }
          }
        };

        this.getTextNodesWithinRange = range => {
          const textNodes = [];
          const treeWalker = document.createTreeWalker(
            range.commonAncestorContainer,
            NodeFilter.SHOW_TEXT,
            null,
            false
          );

          let currentNode;
          while (currentNode = treeWalker.nextNode()) {
            if (range.intersectsNode(currentNode)) {
              textNodes.push(currentNode);
            }
          }

          return textNodes;
        };

        this.isPossibleMemo = (selection, range) => {
          let possible = true;
          let message  = '';

          const needCharCount = 2;
          const selectionText = selection.toString().trim();

          if (!selectionText || selectionText.length < needCharCount) {
            possible = false;
            message  = `Requires least ${ needCharCount } characters`;
          }

          if (possible && document.getElementsByClassName(MEMO_ING_CLASSNAME).length) {
            possible = false;
            message  = 'Already writing memo';
          }

          if (possible) {
            if (range.commonAncestorContainer.parentNode.classList.contains(MEMO_CLASSNAME)) {
              possible = false;
              message  = 'Memo already exists';
            }
          }

          if (possible) {
            const parentTagList = ['li', 'p', 'div'];

            const startNode = selection.anchorNode.parentNode.closest(parentTagList.join(','));
            const endNode   = selection.focusNode.parentNode.closest(parentTagList.join(','));

            if (startNode !== endNode) {
              possible = false;
              message  = 'Only available in the same paragraph';
            }
          }

          if (possible) {
            const textNodes = this.getTextNodesWithinRange(range);

            for (let i = 0, len = textNodes.length; i < len; i++) {
              const textNode = textNodes[i];

              if (textNode.parentNode.classList.contains(MEMO_CLASSNAME)) {
                possible = false;
                message  = 'Memo cannot overlap each other';
                break;
              }
            }
          }

          return { possible, message };
        };

        this.highlightSelectedTextAndOpenModal = () => {
          this.selection    = window.getSelection();
          this.selectedText = this.selection.toString();
          this.range        = this.selection.getRangeAt(0);

          if (this.range) {
            const preSelectionRange = this.range.cloneRange();

            preSelectionRange.selectNodeContents(this.parentTarget);
            preSelectionRange.setEnd(
              this.range.startContainer,
              this.range.startOffset
            );

            this.range.start = preSelectionRange.toString().length;
            this.range.end = this.range.start + this.range.toString().length;

            this.addHighlightElement(this.parentTarget, this.range.start, this.range.end, [ MEMO_CLASSNAME, MEMO_ING_CLASSNAME ]);

            // 선택된 텍스트 하이라이트
            // const span = document.createElement('span');
            // span.classList.add('memo');
            // span.classList.add('memo-ing');
            // span.appendChild(this.range.extractContents());
            // this.range.insertNode(span);

            // 타겟 변경
            // this.target = span;
            // 선택 해제
            this.selection.removeAllRanges();

            this.openModal();
          }
        };

        this.openModal = () => {
          this.modal.style.opacity = 1;
          this.modal.style.visibility = 'visible';
          this.modal.style.pointerEvents = 'auto';
          this.modal.style.left = `${ event.x - (window.innerWidth > event.x + 300 ? 0 : 180) }px`;
          this.modal.style.top  = `${ event.y - (window.innerHeight > event.y + 100 ? 0 : 200) }px`

          setTimeout(() => this.modalTextarea.focus(), 50) ;
        };

        this.hideModal = () => {
          this.modal.style.opacity = 0;
          this.modal.visibility = 'hidden';
          this.modal.style.pointerEvents = 'none';
          this.modal.style.left = '50%';
          this.modal.style.top = '50%';
          this.modalTextarea.value = '';
          this.modalNotice.innerText = '0/100';
        };

        this.setEvent = () => {
          this.setEventSaveButton();
          this.setEventCancelButton();
          this.setEventTextarea();
          this.setEventMousePopup();
        };

        this.setEventTextarea = () => {
          this.modalTextarea.addEventListener('keydown', event => {
            if (event.keyCode === 13) event.preventDefault();
          });
          this.modalTextarea.addEventListener('keyup', () => {
            this.modalNotice.innerText = `${ this.modalTextarea.value.length || 0 }/100`;
          });
        };

        this.setEventSaveButton = () => {
          this.modalSaveBtn.addEventListener('click', () => {
            const memoText = this.modalTextarea.value;

            if (memoText.trim().length === 0) {
              return alert('메모 입력되지 않음');
            }

            console.log(this.range);
            if (this.target) {
              const data = {
                documentId: this.documentId,
                parentSelector: this.parentTarget.id,
                targetText: this.selectedText,
                start: this.range.start,
                end: this.range.end,
                memoText,
              };

              this.target.classList.remove(MEMO_ING_CLASSNAME);

              this.storage.push(data);

              sessionStorage.setItem('data', JSON.stringify(this.storage));
            }

            this.hideModal();
          });
        };

        this.setEventCancelButton = () => {
          this.modalCancelBtn.addEventListener('click', () => {
            const isUpdate = this.target.classList.contains(MEMO_UPDATE_CLASSNAME);

            // if (isUpdate) {
            //   this.target.classList.remove(MEMO_UPDATE_CLASSNAME);
            // } else if (this.target) {
            //   const targetHtml = this.target.outerHTML;

            //   // 취소시 현재 하이라이트 태그 지우기
            //   this.parentTarget.outerHTML = this.parentTarget.outerHTML.replace(
            //     targetHtml,
            //     this.originHtml
            //   );
            // }

            this.hideModal();
          });
        };

        this.openMousePopup = (x, y) => {
          this.mousePopup.style.display  = 'block';
          this.mousePopup.style.position = 'absolute';
          this.mousePopup.style.left     = `${ x - (window.innerWidth > x + 40 ? 0 : 40) }px`;
          this.mousePopup.style.top      = `${ y }px`;
        }

        this.setEventMousePopup = () => {
          this.mousePopup.addEventListener('mouseover', () => this.isPopupHover = true);
          this.mousePopup.addEventListener('mouseout', () => this.isPopupHover = false);

          this.mousePopup.addEventListener('click', () => {
            this.mousePopup.style.display = 'none';

            this.highlightSelectedTextAndOpenModal();
          });

          document.addEventListener('mousedown', () => {
            if (!this.isPopupHover) {
              this.mousePopup.style.display = 'none';
            }
          });
        };

        this.getSelectorPath = element => {
          if (!(element instanceof Element)) return;

          let path = [];
          while (element.nodeType === Node.ELEMENT_NODE) {
            let selector = element.nodeName.toLowerCase();
            if (element.id) {
              selector += '#' + element.id;
            } else {
              let sibling = element, nth = 1;
              while (sibling.nodeType === Node.ELEMENT_NODE && (sibling = sibling.previousSibling) && nth++) {
                selector += `:nth-child(${ nth })`;
              }
            }
            path.unshift(selector);
            if (element.id) break;
            element = element.parentNode;
          }

          return path.join(' > ');
        }

        this.init = () => {
          this.loadStorageAndHighlight();

          this.container.addEventListener('mousedown', () => this.isDragging = false);
          this.container.addEventListener('mousemove', () => this.isDragging = true);

          this.container.addEventListener('mouseup', event => {
            if (!this.isDragging) return;

            const selection = window.getSelection();
            const range     = selection.getRangeAt(0);

            const { possible, message } = this.isPossibleMemo(selection, range);

            if (!possible) {
              console.error(message);
            } else {
              console.log('evet', event.target)
              this.target       = event.target;
              this.parentTarget = this.target.closest('div');

              this.openMousePopup(event.x, event.y);
            }
          });

          this.setEvent();
        };

        this.init();
      }
    </script>
  </body>
</html>
