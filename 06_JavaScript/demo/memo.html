<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Memo</title>
    <style>
      .section {
        display: flex;
        padding: 10px;
        justify-content: space-between;
      }
      .title {
        display: flex;
        justify-content: center;
        align-items: center;
        font-weight: 600;
        min-width: 200px;
        height: inherit;
        border-right: 1px solid black;
        margin-right: 10px;
      }
      p {
        word-break: break-word;
      }
      .memo {
        font-style: italic;
        background-color: #f8ca8f !important;
      }
      .memo:hover {
        text-decoration: underline;
        cursor: pointer;
      }
      .modal {
        position: absolute;
        top: 50%;
        left: 50%;
        margin-left: -140px;
        display: flex;
        margin-top: -50px;
        visibility: hidden;
        opacity: 0;
        justify-content: space-between;
        padding: 10px;
        border-radius: 5px;
        border: 1px solid black;
        width: 300px;
        height: 120px;
        background-color: white;
        box-shadow: 5px 5px 5px #d6d6d6;
        transition: ease 0.5s;
        user-select: none;
      }
      .memo-input {
        padding: 5px;
        width: 200px;
        resize: none;
      }
      .memo-ing {
        background-color: #f9f9c8 !important;
      }
      .memo-update {
        background-color: #9cdef8;
      }
      .text-notice {
        position: absolute;
        top: 107px;
        left: 158px;
        pointer-events: none;
        width: 60px;
        text-align: right;
        opacity: 0.6;
      }
      #memo-popup {
        display: none;
        width: 45px;
        /* height: 15px; */
        background-color: white;
        border: 1px solid #eaeaea;
        border-radius: 5px;
        user-select: none;
      }
      #memo-popup > button {
        user-select: none;
      }
      mark {
        background-color: aqua !important;
        border-radius: 5px;
      }
      mark > .memo {
        background-color: inherit;
      }
    </style>
  </head>
  <body>
    <h1>MEMO TEST</h1>

    <div id="container">
      <div key="FIELD_OF_THE_INVENTION" id="FIELD_OF_THE_INVENTION">
        <p>
          <strong>【Paragraph 1】</strong>
        </p>
        <div key="P-0003" id="P-0003">
          <p>
            <strong>【0001】</strong>
          </p>
          Lorem ipsum dolor sit amet consectetur adipisicing elit. Ab
          asperiores, ullam architecto omnis voluptatum dolor quia, est, saepe
          earum fugiat consectetur dicta autem corporis nemo delectus totam.
          Doloremque voluptate molestiae laboriosam possimus sed? Excepturi
          veritatis, blanditiis ea ratione obcaecati magnam earum magni
          temporibus officiis error porro incidunt ipsum quae repudiandae
          expedita fugiat itaque <span class="memo">memo test</span> delectus.
          Ad quisquam provident odio. Quo iste, in explicabo, nulla tempore
          animi quasi ducimus numquam sint et perferendis ratione accusamus
          mollitia debitis earum voluptates. Cumque officiis expedita
          consequuntur libero labore, assumenda, explicabo dicta, maiores hic
          earum illum modi voluptate consequatur rerum ducimus voluptatum
          doloribus accusantium animi saepe!
          <mark
            data-markjs="true"
            id="-1204461845-1-1"
            name="-1204461845-1"
            class="mark--1204461845 palette-fac76c"
            >organic</mark
          >
          Lorem ipsum dolor sit amet consectetur adipisicing elit. Deserunt,
          sapiente.
        </div>
      </div>

      <div key="FIELD_OF_THE_INVENTION" id="FIELD_OF_THE_INVENTION_2">
        <p>
          <strong>【Paragraph 2】</strong>
        </p>
        <div key="P-0004" id="P-0004">
          <p>
            <strong>【0002】</strong>
          </p>
          Lorem ipsum dolor sit amet consectetur adipisicing elit. Tenetur est
          nemo officiis, qui nam amet enim consequuntur itaque voluptate
          facilis, blanditiis numquam. Magni, veritatis aperiam a modi labore
          esse nisi libero cupiditate possimus, tenetur hic corrupti nemo
          voluptas distinctio deleniti cum quos dolores sapiente temporibus,
          expedita molestias deserunt consequatur maiores! Excepturi inventore
          quia illum ipsam corrupti sint suscipit id molestias accusamus rem
          voluptatum, libero illo dolor fuga exercitationem nam, minima minus
          assumenda dolores. Aliquam corporis odio illo id ex molestias a
          tempore explicabo ad, libero sequi fugit ipsa magnam incidunt
          veritatis nesciunt atque at non eum iusto? Laudantium, molestias eius!
          <mark
            data-markjs="true"
            id="-1204461845-1-1"
            name="-1204461845-1"
            class="mark--1204461845 palette-fac76c"
            >organic</mark
          >
          Lorem ipsum dolor sit amet consectetur adipisicing elit. Magnam
          distinctio modi suscipit quibusdam repellendus, culpa ab dicta ut
          numquam explicabo?
        </div>
        <p>
          <strong>【Paragraph 3】</strong>
        </p>
        <div num="0003">
          <div>【0003】</div>
          Lorem ipsum dolor sit amet consectetur adipisicing elit. Ratione ipsam
          placeat sapiente consequatur repudiandae, numquam similique, ad vel
          tempore dolorem eaque explicabo id temporibus voluptatibus quis harum
          ea saepe perferendis nulla corrupti? Iste fuga excepturi voluptate
          recusandae molestias, dolores numquam.
        </div>
      </div>
    </div>

    <div id="memo-modal" class="modal">
      <textarea
        class="memo-input"
        placeholder="메모를 입력해주세요."
        maxlength="100"
      ></textarea>
      <div class="text-notice">0/100</div>
      <button class="save-btn" type="button">저장</button>
      <button class="cancel-btn" type="button">취소</button>
    </div>

    <div id="memo-popup">
      <button type="button">memo</button>
    </div>

    <script>
      /*
       * 현재 제한 사항
       * 1. 메모가 중복 될 수 없음
       * 2. 메모가 현재 문단을 벗어 날 수 없음
       * 3. 드래그한 대상은 2글자 이상일때만 메모 제공
       */
      window.onload = () => {
        const memo = new Memo({ documentId: 'test', containerId: 'container' });
      };

      function Memo({ documentId, containerId }) {
        if (!new.target) {
          throw new Error('Create object using new operator.');
        }

        const COMMON_REGEX          = /\n {2,}/g;
        const MEMO_CLASSNAME        = 'memo';
        const MEMO_ING_CLASSNAME    = 'memo-ing';

        this.isDragging = false;
        this.ingMemoKey = 0;

        this.documentId = documentId || '';
        this.container  = document.getElementById(containerId);

        this.storage = JSON.parse(sessionStorage.getItem('data')) || [];

        this.target       = null;
        this.parentTarget = null;

        this.selection    = null;
        this.range        = null;
        this.selectedText = null;
        this.originHtml   = null;

        this.modal          = document.getElementById('memo-modal');
        this.modalTextarea  = this.modal.querySelector('textarea.memo-input');
        this.modalSaveBtn   = this.modal.querySelector('button.save-btn');
        this.modalCancelBtn = this.modal.querySelector('button.cancel-btn');
        this.modalNotice    = this.modal.querySelector('div.text-notice');

        this.mousePopup   = document.getElementById('memo-popup');
        this.isPopupHover = false;

        this.groupedData = data => {
          const result = {};

          for (let i = 0, len = data.length; i < len; i++) {
            const item = data[i];
            const { parentSelector } = item;

            if (!result[parentSelector]) {
              result[parentSelector] = [];
            }

            result[parentSelector].push(item);
          }

          return result;
        };

        this.TextByRegex = text => text.replace(COMMON_REGEX, ' ');

        this.createTreeWalker = element => document.createTreeWalker(element, NodeFilter.SHOW_TEXT);

        this.removeHighlightElement = (element, memoKey) => {
          let treeWalker = this.createTreeWalker(element);
          let currentNode;
          while (currentNode = treeWalker.nextNode()) {
            const parentNode = currentNode.parentNode;
            const nodeText   = currentNode.nodeValue;

            if (parentNode.getAttribute('memo-key') === memoKey) {
              const targetTextNode = document.createTextNode(nodeText);
              const previousNodeParent = treeWalker.previousNode().parentNode;

              previousNodeParent.replaceChild(targetTextNode, parentNode)
            }
          }
        };

        this.addHighlightElement = (element, start, end, memoKey, classNames = []) => {
          if (end < start) throw new Error('Incorrect data');

          let treeWalker = this.createTreeWalker(element);
          let currentNode;
          while (currentNode = treeWalker.nextNode()) {
            const nodeText       = this.TextByRegex(currentNode.nodeValue);
            const nodeTextLength = nodeText.length;

            if (!nodeText) continue;

            if (start >= nodeTextLength) {
              start -= nodeTextLength;
              end   -= nodeTextLength;
            } else {
              const parentNode = currentNode.parentNode;

              const beforeText = nodeText.substring(0, start);
              const targetText = nodeText.substring(start, Math.min(end, nodeTextLength));
              const afterText  = nodeText.substring(Math.min(end, nodeTextLength));

              const beforeTextNode = document.createTextNode(beforeText);
              const targetTextNode = document.createElement('span');
              const afterTextNode  = document.createTextNode(afterText);

              targetTextNode.setAttribute('memo-key', memoKey)
              targetTextNode.textContent = targetText;
              for (const className of classNames) {
                targetTextNode.classList.add(className);
              }

              parentNode.replaceChild(afterTextNode, currentNode);
              parentNode.insertBefore(targetTextNode, afterTextNode);
              parentNode.insertBefore(beforeTextNode, targetTextNode);

              start = 0;
              end  -= targetText.length + beforeText.length;

              if (end <= 0) break;

              treeWalker = this.createTreeWalker(element);
              treeWalker.currentNode = afterTextNode;
            }
          }
        };

        this.loadStorageAndHighlight = () => {
          if (this.storage && this.storage.length) {
            const groupData = this.groupedData(
              this.storage.sort((a, b) => {
                if (a.parentSelector < b.parentSelector) return -1;
                if (a.parentSelector > b.parentSelector) return 1;
                if (a.start > b.start) return -1;
                if (a.start < b.start) return 1;
                return 0;
              })
            );

            for (const groupSelector in groupData) {
              if (groupData[groupSelector]) {
                const items   = groupData[groupSelector];
                const element = document.querySelector(groupSelector);

                for (let i = 0, itemLen = items.length; i < itemLen; i++) {
                  const item = items[i];
                  const { start, end, targetText, memoKey } = item;

                  this.addHighlightElement(element, start, end, memoKey, [ MEMO_CLASSNAME ]);
                }
              }
            }
          }
        };

        this.getTextNodesWithinRange = (range) => {
          const textNodes = [];
          const treeWalker = this.createTreeWalker(range.commonAncestorContainer);

          let currentNode;
          while (currentNode = treeWalker.nextNode()) {
            if (range.intersectsNode(currentNode)) {
              textNodes.push(currentNode);
            }
          }

          return textNodes;
        };

        this.isPossibleMemo = (selection, range) => {
          let possible = true;
          let message  = '';

          const needCharCount = 2;
          const selectionText = selection.toString().trim();

          if (!selectionText || selectionText.length < needCharCount) {
            possible = false;
            message  = `Requires least ${needCharCount} characters`;
          }

          if ( possible && document.getElementsByClassName(MEMO_ING_CLASSNAME).length) {
            possible = false;
            message  = 'Already writing memo';
          }

          if (possible) {
            if (range.commonAncestorContainer.parentNode.classList.contains(MEMO_CLASSNAME)) {
              possible = false;
              message  = 'Memo already exists';
            }
          }

          if (possible) {
            const parentTagList = ['li', 'p', 'div'];

            const startNode = selection.anchorNode.parentNode.closest(parentTagList.join(','));
            const endNode   = selection.focusNode.parentNode.closest(parentTagList.join(','));

            if (startNode !== endNode) {
              possible = false;
              message  = 'Only available in the same paragraph';
            }
          }

          if (possible) {
            const textNodes = this.getTextNodesWithinRange(range);

            for (let i = 0, len = textNodes.length; i < len; i++) {
              const textNode = textNodes[i];

              if (textNode.parentNode.classList.contains(MEMO_CLASSNAME)) {
                possible = false;
                message  = 'Memo cannot overlap each other';
                break;
              }
            }
          }

          return { possible, message };
        };

        this.highlightSelectedTextAndOpenModal = () => {
          this.selection    = window.getSelection();
          this.selectedText = this.selection.toString();
          this.range        = this.selection.getRangeAt(0);

          if (this.range) {
            this.ingMemoKey = Math.floor(Math.random() * 10_000) + '';
            const preSelectionRange = this.range.cloneRange();

            preSelectionRange.selectNodeContents(this.parentTarget);
            preSelectionRange.setEnd(this.range.startContainer, this.range.startOffset);

            this.range.start = this.TextByRegex(preSelectionRange.toString()).length;
            this.range.end   = this.range.start + this.TextByRegex(this.range.toString()).length;

            this.addHighlightElement(this.parentTarget, this.range.start, this.range.end, this.ingMemoKey, [ MEMO_CLASSNAME, MEMO_ING_CLASSNAME ]);

            this.selection.removeAllRanges();

            this.openModal();
          }
        };

        this.openModal = () => {
          this.modal.style.opacity       = 1;
          this.modal.style.visibility    = 'visible';
          this.modal.style.pointerEvents = 'auto';
          this.modal.style.left          = `${ event.x - (window.innerWidth > event.x + 300 ? 0 : 180) }px`;
          this.modal.style.top           = `${ event.y - (window.innerHeight > event.y + 100 ? 0 : 200) }px`;

          setTimeout(() => this.modalTextarea.focus(), 50);
        };

        this.hideModal = () => {
          this.modal.style.opacity       = 0;
          this.modal.visibility          = 'hidden';
          this.modal.style.pointerEvents = 'none';
          this.modal.style.left          = '50%';
          this.modal.style.top           = '50%';
          this.modalTextarea.value       = '';
          this.modalNotice.innerText     = '0/100';
        };

        this.setEvent = () => {
          this.setEventSaveButton();
          this.setEventCancelButton();
          this.setEventTextarea();
          this.setEventMousePopup();
        };

        this.setEventTextarea = () => {
          this.modalTextarea.addEventListener('keydown', (event) => event.keyCode === 13 && event.preventDefault());
          this.modalTextarea.addEventListener('keyup', () => this.modalNotice.innerText = `${ this.modalTextarea.value.length || 0 }/100`);
        };

        this.setEventSaveButton = () => {
          this.modalSaveBtn.addEventListener('click', () => {
            const memoText = this.modalTextarea.value;

            if (memoText.trim().length === 0) {
              return alert('메모 입력되지 않음');
            }

            if (this.target) {
              const data = {
                documentId    : this.documentId,
                parentSelector: this.getSelectorPath(this.parentTarget),
                targetText    : this.selectedText,
                start         : this.range.start,
                end           : this.range.end,
                memoKey       : this.ingMemoKey,
                memoText,
              };

              for (const ingTag of [ ...this.parentTarget.getElementsByClassName(MEMO_ING_CLASSNAME) ]) {
                ingTag.classList.remove(MEMO_ING_CLASSNAME);
              }


              this.storage.push(data);

              sessionStorage.setItem('data', JSON.stringify(this.storage));
            }

            this.hideModal();
          });
        };

        this.setEventCancelButton = () => {
          this.modalCancelBtn.addEventListener('click', () => {
            this.removeHighlightElement(this.parentTarget, this.ingMemoKey);

            this.hideModal();
          });
        };

        this.openMousePopup = () => {
          this.mousePopup.style.display  = 'block';
          this.mousePopup.style.position = 'absolute';
          this.mousePopup.style.left     = `${ event.x - (window.innerWidth > event.x + 40 ? 0 : 40) }px`;
          this.mousePopup.style.top      = `${ event.y }px`;
        };

        this.setEventMousePopup = () => {
          this.mousePopup.addEventListener('mouseover', () => this.isPopupHover = true);
          this.mousePopup.addEventListener('mouseout', () => this.isPopupHover = false);

          this.mousePopup.addEventListener('click', () => {
            this.mousePopup.style.display = 'none';

            this.highlightSelectedTextAndOpenModal();
          });

          document.addEventListener('mousedown', () => {
            if (!this.isPopupHover) {
              this.mousePopup.style.display = 'none';
            }
          });
        };

        this.getSelectorPath = element => {
          if (!(element instanceof Element)) return;

          let path = [];
          while (element.nodeType === Node.ELEMENT_NODE) {
            let selector = element.nodeName.toLowerCase();

            if (element.id) {
              selector += `#${ element.id }`;
            } else {
              let sibling = element, nth = 1;
              while (sibling.nodeType === Node.ELEMENT_NODE && (sibling = sibling.previousSibling) && nth++) {
                selector += `:nth-child(${ nth })`;
              }
            }
            path.unshift(selector);

            if (element.id) break;
            element = element.parentNode;
          }

          return path.join(' > ');
        };

        this.init = () => {
          this.loadStorageAndHighlight();

          this.container.addEventListener('mousedown', () => this.isDragging = false);
          this.container.addEventListener('mousemove', () => this.isDragging = true);

          this.container.addEventListener('mouseup', event => {
            if (!this.isDragging) return;

            const selection = window.getSelection();
            const range     = selection.getRangeAt(0);

            const { possible, message } = this.isPossibleMemo(selection, range);

            if (!possible) {
              console.error(message);
            } else {
              this.target       = event.target;
              this.parentTarget = this.target.closest('div');

              this.openMousePopup();
            }
          });

          this.setEvent();
        };

        this.init();
      }
    </script>
  </body>
</html>
