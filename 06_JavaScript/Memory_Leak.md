# Memory Leak

## 1. Memory Leak?

- Memory Leak(메모리 누수)는 **메모리 풀에서 반환되지 않으면서 애플리케이션에서 더 이상 쓰지 않는 메모리**로 정의 가능
- 각 프로그래밍 언어는 메모리 관리를 각각 다른 방법으로 처리하므로 메모리 누수 발생 가능성을 감소시킴

### 1.1 In JavaScript

- JavaScript에서는 GC(Garbage Collector)를 사용하여 메모리 관리하는데 도움을 줌
  - 메모리 영역이 **프로그램에서 여전히 참조 가능한지를 주기적으로 확인(도달 가능성, reachability)**하여 메모리 관리
  - 이같은 GC 언어는 메모리 관리 문제를 '프로그램에서 여전히 참조 가능한가?'에 관심이 있음
- GC언어의 메모리 누수의 주된 원인은 **원치 않는 참조(unwanted references)**

#### 1.1.1 Reference-counting 알고리즘

- 어떠한 오브젝트도 참조하지 않는 오브젝트, 즉 **특정 오브젝트를 참조하는 다른 오브젝트가 하나도 없을때 GC 실행**

```javascript
var x = {
    a: {
        b: 2
    }
};

var y = x;		// 'y' 변수는 위 오브젝트를 참조하는 두 번째 변수

x = 1;			// 'y' 변수가 위의 오브젝트를 참조하는 유일한 변수가 됨

var z = y.a;	// 'y.a'는 두 개의 참조를 가짐('y'가 속성으로 참조, 'z'가 변수로 참조)

y = 'mozilla';	// 'y' 변수가 참조했던 오브젝트가 없어졌지만, 'a' 속성이 'z' 변수에 참조되므로 메모리 해제 안됨

z = null;		// 이제 'x' 변수가 참조했던 오브젝트를 참조하는 다른 변수가 없으므로 GC 수행
```

- **한계: 순환 참조**

  - 두 객체가 서로 참조하는 속성으로 생성되어 순환 구조를 생성하는 함수가 있음
  - 함수 호출이 완료되면 두 객체는 스코프를 벗어나게 되어, 두 객체는 불필요해지므로 GC 실행되어야 함
  - 하지만 두 객체가 서로를 참조하고 있으므로, GC 대상이되지 않아 메모리 누수의 원인이 됨

  ```javascript
  function f() {
    var x = {};
    var y = {};
    x.a = y;         // x는 y를 참조한다.
    y.a = x;         // y는 x를 참조한다.
  
    return "azerty";
  }
  
  f();
  ```


#### 1.1.2  Mark-and-sweep 알고리즘

- 이 알고리즘은 '더 이상 필요없는 오브젝트'를 **'닿을 수 없는 오브젝트'**로 정의
- roots라는 오브젝트의 집합을 가지고 있음(JavaScript에서는 전역 변수)
  - 주기적으로 GC는 roots부터 시작하여 닿을수 없는 오브젝트에 대해 GC 실행
  - 즉, 닿을 수 있는 메모리는 active로 표시하고 ,나머지는 Garbage로 간주
- 이 알고리즘은 Reference-counting 알고리즘보다 효율적
- 모든 최신 브라우저들은 GC에서 Mark-and-sweep을 사용
- 위 알고리즘의 한계인 순환 참조 예제에서 Mark-and-sweep 알고리즘은 두 오브젝트는 닿을 수 없으므로 GC 실행
- 어떤 메모리를 언제 해제할지에 대해 수동으로 결정하는 것이 편리할 때가 있음
  - 수동으로 객체의 메모리를 해제하려면, 객체 메모리에 도달할 수 없도록 명시하는 기능이 있어야 함
  - 하지만 **현재 JavaScript에서는 명시적으로 또는 프로그래밍 방식으로 GC를 작동할 수 없음**