# 좋은 JavaScript Programming

## 1. 바르게 시작하는 코드 작성하기

### 1.1 JavaScript 특성을 완벽히 섭렵하자

#### 1.1.1 Single Thread

- JavaScript(이하 JS)는 single thread로 움직이지만, **blocking 모델은 아니라서 비동기 프로그래밍**을 해야 함
- Multi thread 언어에서는 작업을 해당 코드와 병렬 실행시킬 수 있지만, **JS는 어떤 이벤트가 끝나자마자 실행할 함수를 큐에 넣는 것이 고작**
- 프로세서를 독차지할 염려가 없음

### 1.2 대규모 시스템에서는 JS 함정을 피하자

- 클라이언트/서버 양쪽에서 규모가 큰 시스템의 부하를 감당 가능하게 해주는 SPA, Node.JS 같은 기술이 등장하면서 **개발자는 통신 채널을 최소화하는 문제를 진지하게 고민**하게 됨
- 본연의 임무를 수행하기 위해 객체 간 인터페이스가 불가피하다면 어떤 상황에서도 모든 객체가 올바르게 작동하게끔 지속해서 연결을 관리해야 함

#### 1.2.1 스크립트는 모듈이 아님

- 한 페이지에 스크립트가 하나밖에 없던 시절에는 전역에 함수를 추가해도 별 탈이 없었음
- 하지만 현대의 스크립트는 하나만 사용하지 않으니 문제가 발생함
- **정말 필요한 경우가 아니라면 전역에 변수나 함수를 사용하지 않는 것을 추천**

#### 1.2.2 스코프는 중첩 함수로 다스림

- JS는 함수를 중첩하여 코드를 계층화 가능
- 덕분에 개발자가 원하는 것을 찾는 데 도움이 될 뿐만 아니라 프로그램에서 변수/함수의 스코프를 최소화 가능
- 이러한 특성이 대규모 시스템을 효과적으로 유지하는 핵심이자 JS 코드의 탁월한 근본 요소
- **클로저를 교묘하게 잘 섞어 쓰면 대규모 JS 시스템에 꼭 필요한, 강력한 도구가 될 수 있음**

#### 1.2.3 규약을 지켜 코딩하자

- **대규모 시스템을 잘 꾸려 나가려면 가능한 작게 만들어야 효과적**
- JS는 덕 타이핑의 유연성 덕분에 적은 코드로도 많은 일을 할 수 있지만, 자신의 프로그램에 누가 무엇을 넣을지 알수 없음
- **함수 인자에 특정한 조건이 있다면 그 값을 꼭 검증해야 함**
  - 덕 타이핑(Duck Typing):  객체의 변수 및 메소드의 집합이 객체의 타입을 결정하는 동적 타이핑 종류

### 1.3 소프트웨어 공학 원칙 적용하자

#### 1.3.1 SOLID 원칙

- **Single Responsibility Principle(단일 책임 원칙)**
  - 객체는 반드시 **한 가지 변경 사유**를 가져야 한다는 원칙
- **Open/Closed Principle(개방/폐쇄 원칙)**
  - 객체는 확장 가능성을 열어 두되 수정 가능성은 닫아야 한다는 원칙
  - 즉, 어떤 경우라도 실행 코드를 변경하지 말고, 재사용하고 확장하라는 의미
- **Liskov Substitution Principle(리스코프 치환 원칙)**
  - 어떤 타입에서 파생된 타입의 객체가 있다면 이타입을 사용하는 코드는 변경하지 말아야 한다는 원칙
  - 즉, 한 객체를 다른 객체에서 파생하더라도 그 기본 로직이 변경되어서는 안된다라는 의미
- **Interface Segregation Principle(인터페이스 분리 원칙)**
  - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다는 원칙
  - 즉, 기능이 많은 인터페이스는 더 작게 응축시킨 조각으로 나누어야 한다는 의미
  - JS에서는 함수가 기대하는 인자가 무엇인지 명확히 하고 그 기대치를 최쇠하해야 함
- **Dependency Inversion Principle(의존성 역전 원칙)**
  - 상위 수준 모듈은 하위 수준 모듈에 의존해서는 안되며 이 둘은 추상화에 의존해야한다는 원칙
- **DRY(Don't Repeat Yourself) 원칙**
  - 반복하지 마라라는 말 역시 좋은 소프트웨어 개발 습관의 근원
  - DRY함은 잘못코딩한 코드를 컴파일러가 미리 알려주지 않으니 JS에서 특별히 더 중요

## 2. 바르게 유지되는 코드 작성하기

### 2.1 단위 테스트는 미래에 대비한 투자

- **단위 테스트(Unit Test)**는 시간이 흐르면서 아무리 큰 변화의 소용돌이 속에 빠져도 완벽한 프로그램을 만들 수 있게 함
- **단위(Unit)**란 특정 조건에서 어떻게 작동해야 할지 정의한 것, 언제나 그런 것은 아니지만 대개 함수로 표현
- 단위 테스트 본체에 작성한 코드는 **준비(arrange)**, **실행(act)**, **단언(assert)**의 패턴을 따름
  - 테스트 **준비**: 단위를 실행할 조건을 확실히 정하고, 의존성 및 함수 입력 데이터를 설정
  - 단위를 **실행**하여 테스트
  - 테스트 **단언**: 미리 정한 조건에 따라 예상대로 단위가 작동하는지 확인
- **전체 단위 테스트 꾸러미(test suite)를 작성하는 데 든 시간과 노력은 프로그램이 직면할 갖가지 변화에 대처하기 위한 보험이자, 안정적인 애플리케이션 유지에 꼭 필요한 최선의 투자**

### 2.2 테스트 주도 개발(TDD) 실천

- **TDD는 처음부터 프로그램을 제대로 작성했는지 확실히 보장**
- TDD에서는 애플리케이션 코드를 짜기 **전에** 이 코드가 통과해야 할 단위 테스트를 **먼저** 작성
- 마치 애플리케이션을 개발하듯 전체 단위 테스트 꾸러미를 만들어가는 TDD 방식을 따르면 단위 정의와 인터페이스 설계에 도움이 됨

### 2.3 테스트하기 쉬운 코드로 다듬기

- 테스트하기 쉬운 코드를 작성하려면 가장 중요한 단계는 관심사를 적절히 분리하는 일
- 관심사를 제대로 분리하지 않은 채 먼저 코딩하고 테스트를 작성하는 식으로 진행하면 정말 늦어지게 될 것이라 확신
- 적색-녹색-리팩터 과정을 반복하며 작은 코드를 개발하다 보면 점점 속도가 붙게 됨
  - 작은 코드는 대개 간단하고 실수할 가능성이 작아 디버깅 시간을 상당히 줄일 수 있음
  - 테스트로 코드를 완전히 커버하니 리팩토링을 하더라도 무서울게 없음
  - 따라서 코드를 DRY하게 유지하여 오류 발생 여지를 줄이고 규모를 작게 가져갈 수 있음
