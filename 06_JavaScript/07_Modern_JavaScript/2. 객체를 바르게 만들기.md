# 객체를 바르게 만들기

## 1. 원시형(Primitive types)

- JavaScript 원시형은 5개 String, Number, Boolean, null, undefined에 ES6에서 추가된 Symbol이 있음

  - 객체 Object는 원시형에 속하지 않음

- 원시형 변수는 값은 있지만 Property가 없어서 문자열 같은 경우는 에러가 날 것 같지만 실행됨

  ```javascript
  var str = 'abcde';
  console.log(str.length); // 5
  ```

  - String 객체를 만들어 내고 이 객체의 length Property 값을 참조, 이렇게 만든 String 객체는 곧바로 가비지컬렉션 대상이 됨

- **String, Boolean, Number 타입 모두 그들만의 객체 래퍼(wrapper), 즉 String(값), Boolean(값), Number(값)을 지님**

- 불청객 WET(Write Everything Twice(쓴 코드를 또 씀)) 또는 We Enjoy Typing(난 입력하는 게 좋음)은 주의해야 함

  ```javascript
  if (inputMass < 0) {
      // 무게가 음수일 수는 없음
  } else if (inputMass > 150_000) {
      // 이런 무게의 동물은 없음
  }
  ```

  - DRY와는 거리가 먼 이런 코드를 개선하려면?
  - 원시형에 범위 체크 기능을 심을 순 없으니 객체로 변환, 하지만 **원시형을 무조건 객체로 바꾸는 것은 아니고 고려 가능**
  - 원시형을 자꾸 반복하는 건 좋지 않음
    - 변수에 값을 넣고 다른 곳에서 참조하느니 아무래도 그냥 값을 한 번 더 입력하는 것이 알기 쉽고 편함
    - 한 번 이상 참조할 상수는 변수에 담아두고 변수를 대신 참조

## 2. 객체 리터럴(Object Literal)

- 객체 리터럴은 두 가지 생성 방법 존재

  ```javascript
  // 단순 객체 리터럴(Bare Object Literal)
  var koko = { name: 'Koko', genus: 'gorilla', genius: 'sign language' };
  
  // 객체 리터럴이 함수 반환값인 경우
  var amazeTheWorld = function() {
      // ...
      return { name: 'Koko', genus: 'gorilla', genius: 'sign language' };
  }
  
  var koko = amazeTheWorld();
  ```

- 같은 Property를 지닌 객체 리터럴을 여럿 생성할 때 계속 반복되는 Property를 입력하다 보면 실수하기 쉬움

- 객체 리터럴은 함수 Property를 가질 수 있는데, 두번째 방법처럼 함수에서 반환하는 식의 통제 가능한 방향으로 생성하지 않으면 그 안에 포함된 함수 역시 테스트할 방법이 없음

- AOP 프로그래밍은 변수에 객체 리터럴을 할당하지 않으면 시작부터 문제가 됨

  - 애스팩트를 적용하려면 포인트컷(변수명)이 있어야 하는데 객체 리터럴은 이름 자체가 없기 때문
  - 하지만, 객체 리터럴을 팩토리 함수로 생성하면 반환된 리터럴을 갖고 놀 after 애스팩트에 함수를 래핑 가능

- 단순 객체 리터럴에서는 DI는 시도조차 해볼 기회가 없지만, 리터럴을 생성/반환하는 함수는 애플리케이션 시작부에서 의존성을 주입하는 과정에 잘 어울림

- **객체 리터럴은 싱글톤 또는 확실히 테스트를 마친 코드에서 생성된 객체 리터럴이 아닌한 중요한 애플리케이션에는 사용하지 말자**

